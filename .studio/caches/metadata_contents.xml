<?xml version="1.0" ?><org.mule.tooling.metadata.cache.MetadataCache><version>3.5.0.07</version><projectMetadataCache><entry><string>Web_Service_talend</string><map><entry><string>putItemWithReport</string><map><entry><string>__default__</string><org.mule.tooling.metadata.cache.DefaultMetadataCacheEntry><input class="org.mule.common.metadata.DefaultMetaData"><payload class="org.mule.common.metadata.DefaultXmlMetaDataModel"><dataType>XML</dataType><metaDataModelPropertiesManager><properties><org.mule.common.metadata.property.TextBasedExampleMetaDataModelProperty></org.mule.common.metadata.property.TextBasedExampleMetaDataModelProperty></properties></metaDataModelPropertiesManager><fields><org.mule.common.metadata.DefaultMetaDataField><name>arg0</name><model class="org.mule.common.metadata.DefaultXmlMetaDataModel"><dataType>XML</dataType><metaDataModelPropertiesManager><properties></properties></metaDataModelPropertiesManager><fields><org.mule.common.metadata.DefaultMetaDataField><name>invokeBeforeSaving</name><model class="org.mule.common.metadata.DefaultSimpleMetaDataModel"><dataType>BOOLEAN</dataType><metaDataModelPropertiesManager><properties></properties></metaDataModelPropertiesManager></model><accessType>READ_WRITE</accessType><metaDataFieldPropertyManager><properties><org.mule.common.metadata.property.QNameMetaDataProperty><name><namespaceURI></namespaceURI><localPart>invokeBeforeSaving</localPart><prefix></prefix></name></org.mule.common.metadata.property.QNameMetaDataProperty></properties></metaDataFieldPropertyManager></org.mule.common.metadata.DefaultMetaDataField><org.mule.common.metadata.DefaultMetaDataField><name>source</name><model class="org.mule.common.metadata.DefaultSimpleMetaDataModel"><dataType>STRING</dataType><metaDataModelPropertiesManager><properties></properties></metaDataModelPropertiesManager></model><accessType>READ_WRITE</accessType><metaDataFieldPropertyManager><properties><org.mule.common.metadata.property.QNameMetaDataProperty><name><namespaceURI></namespaceURI><localPart>source</localPart><prefix></prefix></name></org.mule.common.metadata.property.QNameMetaDataProperty></properties></metaDataFieldPropertyManager></org.mule.common.metadata.DefaultMetaDataField><org.mule.common.metadata.DefaultMetaDataField><name>wsPutItem</name><model class="org.mule.common.metadata.DefaultXmlMetaDataModel"><dataType>XML</dataType><metaDataModelPropertiesManager><properties></properties></metaDataModelPropertiesManager><fields><org.mule.common.metadata.DefaultMetaDataField><name>isUpdate</name><model class="org.mule.common.metadata.DefaultSimpleMetaDataModel"><dataType>BOOLEAN</dataType><metaDataModelPropertiesManager><properties></properties></metaDataModelPropertiesManager></model><accessType>READ_WRITE</accessType><metaDataFieldPropertyManager><properties><org.mule.common.metadata.property.QNameMetaDataProperty><name><namespaceURI></namespaceURI><localPart>isUpdate</localPart><prefix></prefix></name></org.mule.common.metadata.property.QNameMetaDataProperty></properties></metaDataFieldPropertyManager></org.mule.common.metadata.DefaultMetaDataField><org.mule.common.metadata.DefaultMetaDataField><name>wsDataClusterPK</name><model class="org.mule.common.metadata.DefaultXmlMetaDataModel"><dataType>XML</dataType><metaDataModelPropertiesManager><properties></properties></metaDataModelPropertiesManager><fields><org.mule.common.metadata.DefaultMetaDataField><name>pk</name><model class="org.mule.common.metadata.DefaultSimpleMetaDataModel"><dataType>STRING</dataType><metaDataModelPropertiesManager><properties></properties></metaDataModelPropertiesManager></model><accessType>READ_WRITE</accessType><metaDataFieldPropertyManager><properties><org.mule.common.metadata.property.QNameMetaDataProperty><name><namespaceURI></namespaceURI><localPart>pk</localPart><prefix></prefix></name></org.mule.common.metadata.property.QNameMetaDataProperty></properties></metaDataFieldPropertyManager></org.mule.common.metadata.DefaultMetaDataField></fields><schemas class="org.mule.common.metadata.StringBasedSchemaProvider"><schemas><string>&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;xs:schema xmlns:xs="http://www.w3.org/2001/XMLSchema" xmlns:ns1="http://schemas.xmlsoap.org/soap/http" xmlns:soap="http://schemas.xmlsoap.org/wsdl/soap/" xmlns:tns="http://www.talend.com/mdm" xmlns:wsdl="http://schemas.xmlsoap.org/wsdl/" xmlns:xsd="http://www.w3.org/2001/XMLSchema" elementFormDefault="unqualified" targetNamespace="http://www.talend.com/mdm" version="1.0"&gt;

  &lt;xs:element name="checkFKIntegrity" type="tns:checkFKIntegrity"/&gt;

  &lt;xs:element name="checkFKIntegrityResponse" type="tns:checkFKIntegrityResponse"/&gt;

  &lt;xs:element name="checkSchema" type="tns:checkSchema"/&gt;

  &lt;xs:element name="checkSchemaResponse" type="tns:checkSchemaResponse"/&gt;

  &lt;xs:element name="checkServiceConfiguration" type="tns:checkServiceConfiguration"/&gt;

  &lt;xs:element name="checkServiceConfigurationResponse" type="tns:checkServiceConfigurationResponse"/&gt;

  &lt;xs:element name="count" type="tns:count"/&gt;

  &lt;xs:element name="countItemsByCustomFKFilters" type="tns:countItemsByCustomFKFilters"/&gt;

  &lt;xs:element name="countItemsByCustomFKFiltersResponse" type="tns:countItemsByCustomFKFiltersResponse"/&gt;

  &lt;xs:element name="countResponse" type="tns:countResponse"/&gt;

  &lt;xs:element name="deleteBusinessConcept" type="tns:deleteBusinessConcept"/&gt;

  &lt;xs:element name="deleteBusinessConceptResponse" type="tns:deleteBusinessConceptResponse"/&gt;

  &lt;xs:element name="deleteDataCluster" type="tns:deleteDataCluster"/&gt;

  &lt;xs:element name="deleteDataClusterResponse" type="tns:deleteDataClusterResponse"/&gt;

  &lt;xs:element name="deleteDataModel" type="tns:deleteDataModel"/&gt;

  &lt;xs:element name="deleteDataModelResponse" type="tns:deleteDataModelResponse"/&gt;

  &lt;xs:element name="deleteItem" type="tns:deleteItem"/&gt;

  &lt;xs:element name="deleteItemResponse" type="tns:deleteItemResponse"/&gt;

  &lt;xs:element name="deleteItemWithReport" type="tns:deleteItemWithReport"/&gt;

  &lt;xs:element name="deleteItemWithReportResponse" type="tns:deleteItemWithReportResponse"/&gt;

  &lt;xs:element name="deleteItems" type="tns:deleteItems"/&gt;

  &lt;xs:element name="deleteItemsResponse" type="tns:deleteItemsResponse"/&gt;

  &lt;xs:element name="deleteMenu" type="tns:deleteMenu"/&gt;

  &lt;xs:element name="deleteMenuResponse" type="tns:deleteMenuResponse"/&gt;

  &lt;xs:element name="deleteRole" type="tns:deleteRole"/&gt;

  &lt;xs:element name="deleteRoleResponse" type="tns:deleteRoleResponse"/&gt;

  &lt;xs:element name="deleteRoutingOrderV2" type="tns:deleteRoutingOrderV2"/&gt;

  &lt;xs:element name="deleteRoutingOrderV2Response" type="tns:deleteRoutingOrderV2Response"/&gt;

  &lt;xs:element name="deleteRoutingRule" type="tns:deleteRoutingRule"/&gt;

  &lt;xs:element name="deleteRoutingRuleResponse" type="tns:deleteRoutingRuleResponse"/&gt;

  &lt;xs:element name="deleteStoredProcedure" type="tns:deleteStoredProcedure"/&gt;

  &lt;xs:element name="deleteStoredProcedureResponse" type="tns:deleteStoredProcedureResponse"/&gt;

  &lt;xs:element name="deleteTransformerV2" type="tns:deleteTransformerV2"/&gt;

  &lt;xs:element name="deleteTransformerV2Response" type="tns:deleteTransformerV2Response"/&gt;

  &lt;xs:element name="deleteView" type="tns:deleteView"/&gt;

  &lt;xs:element name="deleteViewResponse" type="tns:deleteViewResponse"/&gt;

  &lt;xs:element name="dropItem" type="tns:dropItem"/&gt;

  &lt;xs:element name="dropItemResponse" type="tns:dropItemResponse"/&gt;

  &lt;xs:element name="executeRoutingOrderV2Asynchronously" type="tns:executeRoutingOrderV2Asynchronously"/&gt;

  &lt;xs:element name="executeRoutingOrderV2AsynchronouslyResponse" type="tns:executeRoutingOrderV2AsynchronouslyResponse"/&gt;

  &lt;xs:element name="executeRoutingOrderV2Synchronously" type="tns:executeRoutingOrderV2Synchronously"/&gt;

  &lt;xs:element name="executeRoutingOrderV2SynchronouslyResponse" type="tns:executeRoutingOrderV2SynchronouslyResponse"/&gt;

  &lt;xs:element name="executeStoredProcedure" type="tns:executeStoredProcedure"/&gt;

  &lt;xs:element name="executeStoredProcedureResponse" type="tns:executeStoredProcedureResponse"/&gt;

  &lt;xs:element name="executeTransformerV2" type="tns:executeTransformerV2"/&gt;

  &lt;xs:element name="executeTransformerV2AsJob" type="tns:executeTransformerV2AsJob"/&gt;

  &lt;xs:element name="executeTransformerV2AsJobResponse" type="tns:executeTransformerV2AsJobResponse"/&gt;

  &lt;xs:element name="executeTransformerV2Response" type="tns:executeTransformerV2Response"/&gt;

  &lt;xs:element name="existsDBDataCluster" type="tns:existsDBDataCluster"/&gt;

  &lt;xs:element name="existsDBDataClusterResponse" type="tns:existsDBDataClusterResponse"/&gt;

  &lt;xs:element name="existsDataCluster" type="tns:existsDataCluster"/&gt;

  &lt;xs:element name="existsDataClusterResponse" type="tns:existsDataClusterResponse"/&gt;

  &lt;xs:element name="existsDataModel" type="tns:existsDataModel"/&gt;

  &lt;xs:element name="existsDataModelResponse" type="tns:existsDataModelResponse"/&gt;

  &lt;xs:element name="existsItem" type="tns:existsItem"/&gt;

  &lt;xs:element name="existsItemResponse" type="tns:existsItemResponse"/&gt;

  &lt;xs:element name="existsMenu" type="tns:existsMenu"/&gt;

  &lt;xs:element name="existsMenuResponse" type="tns:existsMenuResponse"/&gt;

  &lt;xs:element name="existsRole" type="tns:existsRole"/&gt;

  &lt;xs:element name="existsRoleResponse" type="tns:existsRoleResponse"/&gt;

  &lt;xs:element name="existsRoutingRule" type="tns:existsRoutingRule"/&gt;

  &lt;xs:element name="existsRoutingRuleResponse" type="tns:existsRoutingRuleResponse"/&gt;

  &lt;xs:element name="existsStoredProcedure" type="tns:existsStoredProcedure"/&gt;

  &lt;xs:element name="existsStoredProcedureResponse" type="tns:existsStoredProcedureResponse"/&gt;

  &lt;xs:element name="existsTransformer" type="tns:existsTransformer"/&gt;

  &lt;xs:element name="existsTransformerPluginV2" type="tns:existsTransformerPluginV2"/&gt;

  &lt;xs:element name="existsTransformerPluginV2Response" type="tns:existsTransformerPluginV2Response"/&gt;

  &lt;xs:element name="existsTransformerResponse" type="tns:existsTransformerResponse"/&gt;

  &lt;xs:element name="existsTransformerV2" type="tns:existsTransformerV2"/&gt;

  &lt;xs:element name="existsTransformerV2Response" type="tns:existsTransformerV2Response"/&gt;

  &lt;xs:element name="existsView" type="tns:existsView"/&gt;

  &lt;xs:element name="existsViewResponse" type="tns:existsViewResponse"/&gt;

  &lt;xs:element name="extractThroughTransformerV2" type="tns:extractThroughTransformerV2"/&gt;

  &lt;xs:element name="extractThroughTransformerV2Response" type="tns:extractThroughTransformerV2Response"/&gt;

  &lt;xs:element name="extractUsingTransformer" type="tns:extractUsingTransformer"/&gt;

  &lt;xs:element name="extractUsingTransformerResponse" type="tns:extractUsingTransformerResponse"/&gt;

  &lt;xs:element name="extractUsingTransformerThruView" type="tns:extractUsingTransformerThruView"/&gt;

  &lt;xs:element name="extractUsingTransformerThruViewResponse" type="tns:extractUsingTransformerThruViewResponse"/&gt;

  &lt;xs:element name="findAllDroppedItemsPKs" type="tns:findAllDroppedItemsPKs"/&gt;

  &lt;xs:element name="findAllDroppedItemsPKsResponse" type="tns:findAllDroppedItemsPKsResponse"/&gt;

  &lt;xs:element name="findBackgroundJobPKs" type="tns:findBackgroundJobPKs"/&gt;

  &lt;xs:element name="findBackgroundJobPKsResponse" type="tns:findBackgroundJobPKsResponse"/&gt;

  &lt;xs:element name="getAutoIncrement" type="tns:getAutoIncrement"/&gt;

  &lt;xs:element name="getAutoIncrementResponse" type="tns:getAutoIncrementResponse"/&gt;

  &lt;xs:element name="getBackgroundJob" type="tns:getBackgroundJob"/&gt;

  &lt;xs:element name="getBackgroundJobResponse" type="tns:getBackgroundJobResponse"/&gt;

  &lt;xs:element name="getBusinessConceptKey" type="tns:getBusinessConceptKey"/&gt;

  &lt;xs:element name="getBusinessConceptKeyResponse" type="tns:getBusinessConceptKeyResponse"/&gt;

  &lt;xs:element name="getBusinessConceptValue" type="tns:getBusinessConceptValue"/&gt;

  &lt;xs:element name="getBusinessConceptValueResponse" type="tns:getBusinessConceptValueResponse"/&gt;

  &lt;xs:element name="getBusinessConcepts" type="tns:getBusinessConcepts"/&gt;

  &lt;xs:element name="getBusinessConceptsResponse" type="tns:getBusinessConceptsResponse"/&gt;

  &lt;xs:element name="getComponentVersion" type="tns:getComponentVersion"/&gt;

  &lt;xs:element name="getComponentVersionResponse" type="tns:getComponentVersionResponse"/&gt;

  &lt;xs:element name="getConceptsInDataCluster" type="tns:getConceptsInDataCluster"/&gt;

  &lt;xs:element name="getConceptsInDataClusterResponse" type="tns:getConceptsInDataClusterResponse"/&gt;

  &lt;xs:element name="getDataCluster" type="tns:getDataCluster"/&gt;

  &lt;xs:element name="getDataClusterPKs" type="tns:getDataClusterPKs"/&gt;

  &lt;xs:element name="getDataClusterPKsResponse" type="tns:getDataClusterPKsResponse"/&gt;

  &lt;xs:element name="getDataClusterResponse" type="tns:getDataClusterResponse"/&gt;

  &lt;xs:element name="getDataModel" type="tns:getDataModel"/&gt;

  &lt;xs:element name="getDataModelPKs" type="tns:getDataModelPKs"/&gt;

  &lt;xs:element name="getDataModelPKsResponse" type="tns:getDataModelPKsResponse"/&gt;

  &lt;xs:element name="getDataModelResponse" type="tns:getDataModelResponse"/&gt;

  &lt;xs:element name="getDigest" type="tns:getDigest"/&gt;

  &lt;xs:element name="getDigestResponse" type="tns:getDigestResponse"/&gt;

  &lt;xs:element name="getFullPathValues" type="tns:getFullPathValues"/&gt;

  &lt;xs:element name="getFullPathValuesResponse" type="tns:getFullPathValuesResponse"/&gt;

  &lt;xs:element name="getItem" type="tns:getItem"/&gt;

  &lt;xs:element name="getItemPKsByCriteria" type="tns:getItemPKsByCriteria"/&gt;

  &lt;xs:element name="getItemPKsByCriteriaResponse" type="tns:getItemPKsByCriteriaResponse"/&gt;

  &lt;xs:element name="getItemPKsByFullCriteria" type="tns:getItemPKsByFullCriteria"/&gt;

  &lt;xs:element name="getItemPKsByFullCriteriaResponse" type="tns:getItemPKsByFullCriteriaResponse"/&gt;

  &lt;xs:element name="getItemResponse" type="tns:getItemResponse"/&gt;

  &lt;xs:element name="getItems" type="tns:getItems"/&gt;

  &lt;xs:element name="getItemsByCustomFKFilters" type="tns:getItemsByCustomFKFilters"/&gt;

  &lt;xs:element name="getItemsByCustomFKFiltersResponse" type="tns:getItemsByCustomFKFiltersResponse"/&gt;

  &lt;xs:element name="getItemsResponse" type="tns:getItemsResponse"/&gt;

  &lt;xs:element name="getItemsSort" type="tns:getItemsSort"/&gt;

  &lt;xs:element name="getItemsSortResponse" type="tns:getItemsSortResponse"/&gt;

  &lt;xs:element name="getMDMCategory" type="tns:getMDMCategory"/&gt;

  &lt;xs:element name="getMDMCategoryResponse" type="tns:getMDMCategoryResponse"/&gt;

  &lt;xs:element name="getMDMConfiguration" type="tns:getMDMConfiguration"/&gt;

  &lt;xs:element name="getMDMConfigurationResponse" type="tns:getMDMConfigurationResponse"/&gt;

  &lt;xs:element name="getMDMJob" type="tns:getMDMJob"/&gt;

  &lt;xs:element name="getMDMJobResponse" type="tns:getMDMJobResponse"/&gt;

  &lt;xs:element name="getMenu" type="tns:getMenu"/&gt;

  &lt;xs:element name="getMenuPKs" type="tns:getMenuPKs"/&gt;

  &lt;xs:element name="getMenuPKsResponse" type="tns:getMenuPKsResponse"/&gt;

  &lt;xs:element name="getMenuResponse" type="tns:getMenuResponse"/&gt;

  &lt;xs:element name="getRole" type="tns:getRole"/&gt;

  &lt;xs:element name="getRolePKs" type="tns:getRolePKs"/&gt;

  &lt;xs:element name="getRolePKsResponse" type="tns:getRolePKsResponse"/&gt;

  &lt;xs:element name="getRoleResponse" type="tns:getRoleResponse"/&gt;

  &lt;xs:element name="getRoutingOrderV2ByCriteriaWithPaging" type="tns:getRoutingOrderV2ByCriteriaWithPaging"/&gt;

  &lt;xs:element name="getRoutingOrderV2ByCriteriaWithPagingResponse" type="tns:getRoutingOrderV2ByCriteriaWithPagingResponse"/&gt;

  &lt;xs:element name="getRoutingOrderV2PKsByCriteria" type="tns:getRoutingOrderV2PKsByCriteria"/&gt;

  &lt;xs:element name="getRoutingOrderV2PKsByCriteriaResponse" type="tns:getRoutingOrderV2PKsByCriteriaResponse"/&gt;

  &lt;xs:element name="getRoutingOrderV2SByCriteria" type="tns:getRoutingOrderV2SByCriteria"/&gt;

  &lt;xs:element name="getRoutingOrderV2SByCriteriaResponse" type="tns:getRoutingOrderV2SByCriteriaResponse"/&gt;

  &lt;xs:element name="getRoutingRule" type="tns:getRoutingRule"/&gt;

  &lt;xs:element name="getRoutingRulePKs" type="tns:getRoutingRulePKs"/&gt;

  &lt;xs:element name="getRoutingRulePKsResponse" type="tns:getRoutingRulePKsResponse"/&gt;

  &lt;xs:element name="getRoutingRuleResponse" type="tns:getRoutingRuleResponse"/&gt;

  &lt;xs:element name="getServiceConfiguration" type="tns:getServiceConfiguration"/&gt;

  &lt;xs:element name="getServiceConfigurationResponse" type="tns:getServiceConfigurationResponse"/&gt;

  &lt;xs:element name="getServiceDocument" type="tns:getServiceDocument"/&gt;

  &lt;xs:element name="getServiceDocumentResponse" type="tns:getServiceDocumentResponse"/&gt;

  &lt;xs:element name="getServicesList" type="tns:getServicesList"/&gt;

  &lt;xs:element name="getServicesListResponse" type="tns:getServicesListResponse"/&gt;

  &lt;xs:element name="getStoredProcedure" type="tns:getStoredProcedure"/&gt;

  &lt;xs:element name="getStoredProcedurePKs" type="tns:getStoredProcedurePKs"/&gt;

  &lt;xs:element name="getStoredProcedurePKsResponse" type="tns:getStoredProcedurePKsResponse"/&gt;

  &lt;xs:element name="getStoredProcedureResponse" type="tns:getStoredProcedureResponse"/&gt;

  &lt;xs:element name="getTransformer" type="tns:getTransformer"/&gt;

  &lt;xs:element name="getTransformerPKs" type="tns:getTransformerPKs"/&gt;

  &lt;xs:element name="getTransformerPKsResponse" type="tns:getTransformerPKsResponse"/&gt;

  &lt;xs:element name="getTransformerPluginV2Configuration" type="tns:getTransformerPluginV2Configuration"/&gt;

  &lt;xs:element name="getTransformerPluginV2ConfigurationResponse" type="tns:getTransformerPluginV2ConfigurationResponse"/&gt;

  &lt;xs:element name="getTransformerPluginV2Details" type="tns:getTransformerPluginV2Details"/&gt;

  &lt;xs:element name="getTransformerPluginV2DetailsResponse" type="tns:getTransformerPluginV2DetailsResponse"/&gt;

  &lt;xs:element name="getTransformerPluginV2SList" type="tns:getTransformerPluginV2SList"/&gt;

  &lt;xs:element name="getTransformerPluginV2SListResponse" type="tns:getTransformerPluginV2SListResponse"/&gt;

  &lt;xs:element name="getTransformerResponse" type="tns:getTransformerResponse"/&gt;

  &lt;xs:element name="getTransformerV2" type="tns:getTransformerV2"/&gt;

  &lt;xs:element name="getTransformerV2PKs" type="tns:getTransformerV2PKs"/&gt;

  &lt;xs:element name="getTransformerV2PKsResponse" type="tns:getTransformerV2PKsResponse"/&gt;

  &lt;xs:element name="getTransformerV2Response" type="tns:getTransformerV2Response"/&gt;

  &lt;xs:element name="getView" type="tns:getView"/&gt;

  &lt;xs:element name="getViewPKs" type="tns:getViewPKs"/&gt;

  &lt;xs:element name="getViewPKsResponse" type="tns:getViewPKsResponse"/&gt;

  &lt;xs:element name="getViewResponse" type="tns:getViewResponse"/&gt;

  &lt;xs:element name="initMDM" type="tns:initMDM"/&gt;

  &lt;xs:element name="initMDMResponse" type="tns:initMDMResponse"/&gt;

  &lt;xs:element name="isItemModifiedByOther" type="tns:isItemModifiedByOther"/&gt;

  &lt;xs:element name="isItemModifiedByOtherResponse" type="tns:isItemModifiedByOtherResponse"/&gt;

  &lt;xs:element name="isPagingAccurate" type="tns:isPagingAccurate"/&gt;

  &lt;xs:element name="isPagingAccurateResponse" type="tns:isPagingAccurateResponse"/&gt;

  &lt;xs:element name="loadDroppedItem" type="tns:loadDroppedItem"/&gt;

  &lt;xs:element name="loadDroppedItemResponse" type="tns:loadDroppedItemResponse"/&gt;

  &lt;xs:element name="logout" type="tns:logout"/&gt;

  &lt;xs:element name="logoutResponse" type="tns:logoutResponse"/&gt;

  &lt;xs:element name="partialPutItem" type="tns:partialPutItem"/&gt;

  &lt;xs:element name="partialPutItemResponse" type="tns:partialPutItemResponse"/&gt;

  &lt;xs:element name="ping" type="tns:ping"/&gt;

  &lt;xs:element name="pingResponse" type="tns:pingResponse"/&gt;

  &lt;xs:element name="processBytesUsingTransformer" type="tns:processBytesUsingTransformer"/&gt;

  &lt;xs:element name="processBytesUsingTransformerAsBackgroundJob" type="tns:processBytesUsingTransformerAsBackgroundJob"/&gt;

  &lt;xs:element name="processBytesUsingTransformerAsBackgroundJobResponse" type="tns:processBytesUsingTransformerAsBackgroundJobResponse"/&gt;

  &lt;xs:element name="processBytesUsingTransformerResponse" type="tns:processBytesUsingTransformerResponse"/&gt;

  &lt;xs:element name="processFileUsingTransformer" type="tns:processFileUsingTransformer"/&gt;

  &lt;xs:element name="processFileUsingTransformerAsBackgroundJob" type="tns:processFileUsingTransformerAsBackgroundJob"/&gt;

  &lt;xs:element name="processFileUsingTransformerAsBackgroundJobResponse" type="tns:processFileUsingTransformerAsBackgroundJobResponse"/&gt;

  &lt;xs:element name="processFileUsingTransformerResponse" type="tns:processFileUsingTransformerResponse"/&gt;

  &lt;xs:element name="putBackgroundJob" type="tns:putBackgroundJob"/&gt;

  &lt;xs:element name="putBackgroundJobResponse" type="tns:putBackgroundJobResponse"/&gt;

  &lt;xs:element name="putBusinessConcept" type="tns:putBusinessConcept"/&gt;

  &lt;xs:element name="putBusinessConceptResponse" type="tns:putBusinessConceptResponse"/&gt;

  &lt;xs:element name="putBusinessConceptSchema" type="tns:putBusinessConceptSchema"/&gt;

  &lt;xs:element name="putBusinessConceptSchemaResponse" type="tns:putBusinessConceptSchemaResponse"/&gt;

  &lt;xs:element name="putDBDataCluster" type="tns:putDBDataCluster"/&gt;

  &lt;xs:element name="putDBDataClusterResponse" type="tns:putDBDataClusterResponse"/&gt;

  &lt;xs:element name="putDataCluster" type="tns:putDataCluster"/&gt;

  &lt;xs:element name="putDataClusterResponse" type="tns:putDataClusterResponse"/&gt;

  &lt;xs:element name="putDataModel" type="tns:putDataModel"/&gt;

  &lt;xs:element name="putDataModelResponse" type="tns:putDataModelResponse"/&gt;

  &lt;xs:element name="putItem" type="tns:putItem"/&gt;

  &lt;xs:element name="putItemArray" type="tns:putItemArray"/&gt;

  &lt;xs:element name="putItemArrayResponse" type="tns:putItemArrayResponse"/&gt;

  &lt;xs:element name="putItemResponse" type="tns:putItemResponse"/&gt;

  &lt;xs:element name="putItemWithCustomReport" type="tns:putItemWithCustomReport"/&gt;

  &lt;xs:element name="putItemWithCustomReportResponse" type="tns:putItemWithCustomReportResponse"/&gt;

  &lt;xs:element name="putItemWithReport" type="tns:putItemWithReport"/&gt;

  &lt;xs:element name="putItemWithReportArray" type="tns:putItemWithReportArray"/&gt;

  &lt;xs:element name="putItemWithReportArrayResponse" type="tns:putItemWithReportArrayResponse"/&gt;

  &lt;xs:element name="putItemWithReportResponse" type="tns:putItemWithReportResponse"/&gt;

  &lt;xs:element name="putMenu" type="tns:putMenu"/&gt;

  &lt;xs:element name="putMenuResponse" type="tns:putMenuResponse"/&gt;

  &lt;xs:element name="putRole" type="tns:putRole"/&gt;

  &lt;xs:element name="putRoleResponse" type="tns:putRoleResponse"/&gt;

  &lt;xs:element name="putRoutingRule" type="tns:putRoutingRule"/&gt;

  &lt;xs:element name="putRoutingRuleResponse" type="tns:putRoutingRuleResponse"/&gt;

  &lt;xs:element name="putServiceConfiguration" type="tns:putServiceConfiguration"/&gt;

  &lt;xs:element name="putServiceConfigurationResponse" type="tns:putServiceConfigurationResponse"/&gt;

  &lt;xs:element name="putStoredProcedure" type="tns:putStoredProcedure"/&gt;

  &lt;xs:element name="putStoredProcedureResponse" type="tns:putStoredProcedureResponse"/&gt;

  &lt;xs:element name="putTransformer" type="tns:putTransformer"/&gt;

  &lt;xs:element name="putTransformerPluginV2Configuration" type="tns:putTransformerPluginV2Configuration"/&gt;

  &lt;xs:element name="putTransformerPluginV2ConfigurationResponse" type="tns:putTransformerPluginV2ConfigurationResponse"/&gt;

  &lt;xs:element name="putTransformerResponse" type="tns:putTransformerResponse"/&gt;

  &lt;xs:element name="putTransformerV2" type="tns:putTransformerV2"/&gt;

  &lt;xs:element name="putTransformerV2Response" type="tns:putTransformerV2Response"/&gt;

  &lt;xs:element name="putView" type="tns:putView"/&gt;

  &lt;xs:element name="putViewResponse" type="tns:putViewResponse"/&gt;

  &lt;xs:element name="quickSearch" type="tns:quickSearch"/&gt;

  &lt;xs:element name="quickSearchResponse" type="tns:quickSearchResponse"/&gt;

  &lt;xs:element name="recoverDroppedItem" type="tns:recoverDroppedItem"/&gt;

  &lt;xs:element name="recoverDroppedItemResponse" type="tns:recoverDroppedItemResponse"/&gt;

  &lt;xs:element name="removeDroppedItem" type="tns:removeDroppedItem"/&gt;

  &lt;xs:element name="removeDroppedItemResponse" type="tns:removeDroppedItemResponse"/&gt;

  &lt;xs:element name="routeItemV2" type="tns:routeItemV2"/&gt;

  &lt;xs:element name="routeItemV2Response" type="tns:routeItemV2Response"/&gt;

  &lt;xs:element name="routingEngineV2Action" type="tns:routingEngineV2Action"/&gt;

  &lt;xs:element name="routingEngineV2ActionResponse" type="tns:routingEngineV2ActionResponse"/&gt;

  &lt;xs:element name="runQuery" type="tns:runQuery"/&gt;

  &lt;xs:element name="runQueryResponse" type="tns:runQueryResponse"/&gt;

  &lt;xs:element name="serviceAction" type="tns:serviceAction"/&gt;

  &lt;xs:element name="serviceActionResponse" type="tns:serviceActionResponse"/&gt;

  &lt;xs:element name="supportStaging" type="tns:supportStaging"/&gt;

  &lt;xs:element name="supportStagingResponse" type="tns:supportStagingResponse"/&gt;

  &lt;xs:element name="updateDigest" type="tns:updateDigest"/&gt;

  &lt;xs:element name="updateDigestResponse" type="tns:updateDigestResponse"/&gt;

  &lt;xs:element name="updateItemMetadata" type="tns:updateItemMetadata"/&gt;

  &lt;xs:element name="updateItemMetadataResponse" type="tns:updateItemMetadataResponse"/&gt;

  &lt;xs:element name="viewSearch" type="tns:viewSearch"/&gt;

  &lt;xs:element name="viewSearchResponse" type="tns:viewSearchResponse"/&gt;

  &lt;xs:element name="xPathsSearch" type="tns:xPathsSearch"/&gt;

  &lt;xs:element name="xPathsSearchResponse" type="tns:xPathsSearchResponse"/&gt;

  &lt;xs:complexType name="putItemWithReportArray"&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element minOccurs="0" name="arg0" type="tns:WSPutItemWithReportArray"/&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;

  &lt;xs:complexType name="WSPutItemWithReportArray"&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element maxOccurs="unbounded" minOccurs="0" name="wsPutItem" nillable="true" type="tns:WSPutItemWithReport"/&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;

  &lt;xs:complexType name="WSPutItemWithReport"&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element minOccurs="0" name="invokeBeforeSaving" type="xs:boolean"/&gt;
      &lt;xs:element minOccurs="0" name="source" type="xs:string"/&gt;
      &lt;xs:element minOccurs="0" name="wsPutItem" type="tns:WSPutItem"/&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;

  &lt;xs:complexType name="WSPutItem"&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element minOccurs="0" name="isUpdate" type="xs:boolean"/&gt;
      &lt;xs:element minOccurs="0" name="wsDataClusterPK" type="tns:WSDataClusterPK"/&gt;
      &lt;xs:element minOccurs="0" name="wsDataModelPK" type="tns:WSDataModelPK"/&gt;
      &lt;xs:element minOccurs="0" name="xmlString" type="xs:string"/&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;

  &lt;xs:complexType name="WSDataClusterPK"&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element minOccurs="0" name="pk" type="xs:string"/&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;

  &lt;xs:complexType name="WSDataModelPK"&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element minOccurs="0" name="pk" type="xs:string"/&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;

  &lt;xs:complexType name="putItemWithReportArrayResponse"&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element minOccurs="0" name="return" type="tns:WSItemPKArray"/&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;

  &lt;xs:complexType name="WSItemPKArray"&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element maxOccurs="unbounded" minOccurs="0" name="wsItemPK" nillable="true" type="tns:WSItemPK"/&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;

  &lt;xs:complexType name="WSItemPK"&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element minOccurs="0" name="conceptName" type="xs:string"/&gt;
      &lt;xs:element maxOccurs="unbounded" minOccurs="0" name="ids" nillable="true" type="xs:string"/&gt;
      &lt;xs:element minOccurs="0" name="wsDataClusterPK" type="tns:WSDataClusterPK"/&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;

  &lt;xs:complexType name="getMDMJob"&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element minOccurs="0" name="arg0" type="tns:WSMDMNULL"/&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;

  &lt;xs:complexType name="WSMDMNULL"&gt;
    &lt;xs:sequence/&gt;
  &lt;/xs:complexType&gt;

  &lt;xs:complexType name="getMDMJobResponse"&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element minOccurs="0" name="return" type="tns:WSMDMJobArray"/&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;

  &lt;xs:complexType name="WSMDMJobArray"&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element maxOccurs="unbounded" minOccurs="0" name="wsMDMJob" nillable="true" type="tns:WSMDMJob"/&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;

  &lt;xs:complexType name="WSMDMJob"&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element minOccurs="0" name="jobName" type="xs:string"/&gt;
      &lt;xs:element minOccurs="0" name="jobVersion" type="xs:string"/&gt;
      &lt;xs:element minOccurs="0" name="suffix" type="xs:string"/&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;

  &lt;xs:complexType name="getTransformerPluginV2Configuration"&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element minOccurs="0" name="arg0" type="tns:WSTransformerPluginV2GetConfiguration"/&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;

  &lt;xs:complexType name="WSTransformerPluginV2GetConfiguration"&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element minOccurs="0" name="jndiName" type="xs:string"/&gt;
      &lt;xs:element minOccurs="0" name="optionalParameter" type="xs:string"/&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;

  &lt;xs:complexType name="getTransformerPluginV2ConfigurationResponse"&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element minOccurs="0" name="return" type="tns:WSString"/&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;

  &lt;xs:complexType name="WSString"&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element minOccurs="0" name="value" type="xs:string"/&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;

  &lt;xs:complexType name="findBackgroundJobPKs"&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element minOccurs="0" name="arg0" type="tns:WSFindBackgroundJobPKs"/&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;

  &lt;xs:complexType name="WSFindBackgroundJobPKs"&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element minOccurs="0" name="status" type="tns:BackgroundJobStatusType"/&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;

  &lt;xs:complexType name="findBackgroundJobPKsResponse"&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element minOccurs="0" name="return" type="tns:WSBackgroundJobPKArray"/&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;

  &lt;xs:complexType name="WSBackgroundJobPKArray"&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element maxOccurs="unbounded" minOccurs="0" name="wsBackgroundJobPK" nillable="true" type="tns:WSBackgroundJobPK"/&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;

  &lt;xs:complexType name="WSBackgroundJobPK"&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element minOccurs="0" name="pk" type="xs:string"/&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;

  &lt;xs:complexType name="existsTransformerV2"&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element minOccurs="0" name="arg0" type="tns:WSExistsTransformerV2"/&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;

  &lt;xs:complexType name="WSExistsTransformerV2"&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element minOccurs="0" name="wsTransformerV2PK" type="tns:WSTransformerV2PK"/&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;

  &lt;xs:complexType name="WSTransformerV2PK"&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element minOccurs="0" name="pk" type="xs:string"/&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;

  &lt;xs:complexType name="existsTransformerV2Response"&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element minOccurs="0" name="return" type="tns:WSBoolean"/&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;

  &lt;xs:complexType name="WSBoolean"&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element name="_true" type="xs:boolean"/&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;

  &lt;xs:complexType name="deleteStoredProcedure"&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element minOccurs="0" name="arg0" type="tns:WSDeleteStoredProcedure"/&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;

  &lt;xs:complexType name="WSDeleteStoredProcedure"&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element minOccurs="0" name="wsStoredProcedurePK" type="tns:WSStoredProcedurePK"/&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;

  &lt;xs:complexType name="WSStoredProcedurePK"&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element minOccurs="0" name="pk" type="xs:string"/&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;

  &lt;xs:complexType name="deleteStoredProcedureResponse"&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element minOccurs="0" name="return" type="tns:WSStoredProcedurePK"/&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;

  &lt;xs:complexType name="removeDroppedItem"&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element minOccurs="0" name="arg0" type="tns:WSRemoveDroppedItem"/&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;

  &lt;xs:complexType name="WSRemoveDroppedItem"&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element minOccurs="0" name="wsDroppedItemPK" type="tns:WSDroppedItemPK"/&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;

  &lt;xs:complexType name="WSDroppedItemPK"&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element minOccurs="0" name="partPath" type="xs:string"/&gt;
      &lt;xs:element minOccurs="0" name="wsItemPK" type="tns:WSItemPK"/&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;

  &lt;xs:complexType name="removeDroppedItemResponse"&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element minOccurs="0" name="return" type="tns:WSDroppedItemPK"/&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;

  &lt;xs:complexType name="deleteItems"&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element minOccurs="0" name="arg0" type="tns:WSDeleteItems"/&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;

  &lt;xs:complexType name="WSDeleteItems"&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element minOccurs="0" name="conceptName" type="xs:string"/&gt;
      &lt;xs:element minOccurs="0" name="override" type="xs:boolean"/&gt;
      &lt;xs:element name="spellTreshold" type="xs:int"/&gt;
      &lt;xs:element minOccurs="0" name="wsDataClusterPK" type="tns:WSDataClusterPK"/&gt;
      &lt;xs:element minOccurs="0" name="wsWhereItem" type="tns:WSWhereItem"/&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;

  &lt;xs:complexType name="WSWhereItem"&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element minOccurs="0" name="whereAnd" type="tns:WSWhereAnd"/&gt;
      &lt;xs:element minOccurs="0" name="whereCondition" type="tns:WSWhereCondition"/&gt;
      &lt;xs:element minOccurs="0" name="whereOr" type="tns:WSWhereOr"/&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;

  &lt;xs:complexType name="WSWhereAnd"&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element maxOccurs="unbounded" minOccurs="0" name="whereItems" nillable="true" type="tns:WSWhereItem"/&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;

  &lt;xs:complexType name="WSWhereCondition"&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element minOccurs="0" name="leftPath" type="xs:string"/&gt;
      &lt;xs:element minOccurs="0" name="operator" type="tns:WSWhereOperator"/&gt;
      &lt;xs:element minOccurs="0" name="rightValueOrPath" type="xs:string"/&gt;
      &lt;xs:element name="spellCheck" type="xs:boolean"/&gt;
      &lt;xs:element minOccurs="0" name="stringPredicate" type="tns:WSStringPredicate"/&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;

  &lt;xs:complexType name="WSWhereOr"&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element maxOccurs="unbounded" minOccurs="0" name="whereItems" nillable="true" type="tns:WSWhereItem"/&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;

  &lt;xs:complexType name="deleteItemsResponse"&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element minOccurs="0" name="return" type="tns:WSInt"/&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;

  &lt;xs:complexType name="WSInt"&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element name="value" type="xs:int"/&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;

  &lt;xs:complexType name="putItemWithReport"&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element minOccurs="0" name="arg0" type="tns:WSPutItemWithReport"/&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;

  &lt;xs:complexType name="putItemWithReportResponse"&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element minOccurs="0" name="return" type="tns:WSItemPK"/&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;

  &lt;xs:complexType name="dropItem"&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element minOccurs="0" name="arg0" type="tns:WSDropItem"/&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;

  &lt;xs:complexType name="WSDropItem"&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element minOccurs="0" name="invokeBeforeDeleting" type="xs:boolean"/&gt;
      &lt;xs:element minOccurs="0" name="override" type="xs:boolean"/&gt;
      &lt;xs:element minOccurs="0" name="partPath" type="xs:string"/&gt;
      &lt;xs:element minOccurs="0" name="source" type="xs:string"/&gt;
      &lt;xs:element minOccurs="0" name="withReport" type="xs:boolean"/&gt;
      &lt;xs:element minOccurs="0" name="wsItemPK" type="tns:WSItemPK"/&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;

  &lt;xs:complexType name="dropItemResponse"&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element minOccurs="0" name="return" type="tns:WSDroppedItemPK"/&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;

  &lt;xs:complexType name="getTransformerV2"&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element minOccurs="0" name="arg0" type="tns:WSGetTransformerV2"/&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;

  &lt;xs:complexType name="WSGetTransformerV2"&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element minOccurs="0" name="wsTransformerV2PK" type="tns:WSTransformerV2PK"/&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;

  &lt;xs:complexType name="getTransformerV2Response"&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element minOccurs="0" name="return" type="tns:WSTransformerV2"/&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;

  &lt;xs:complexType name="WSTransformerV2"&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element minOccurs="0" name="description" type="xs:string"/&gt;
      &lt;xs:element minOccurs="0" name="name" type="xs:string"/&gt;
      &lt;xs:element maxOccurs="unbounded" minOccurs="0" name="processSteps" nillable="true" type="tns:WSTransformerProcessStep"/&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;

  &lt;xs:complexType name="WSTransformerProcessStep"&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element minOccurs="0" name="description" type="xs:string"/&gt;
      &lt;xs:element minOccurs="0" name="disabled" type="xs:boolean"/&gt;
      &lt;xs:element maxOccurs="unbounded" minOccurs="0" name="inputMappings" nillable="true" type="tns:WSTransformerVariablesMapping"/&gt;
      &lt;xs:element maxOccurs="unbounded" minOccurs="0" name="outputMappings" nillable="true" type="tns:WSTransformerVariablesMapping"/&gt;
      &lt;xs:element minOccurs="0" name="parameters" type="xs:string"/&gt;
      &lt;xs:element minOccurs="0" name="pluginJNDI" type="xs:string"/&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;

  &lt;xs:complexType name="WSTransformerVariablesMapping"&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element minOccurs="0" name="hardCoding" type="tns:WSTypedContent"/&gt;
      &lt;xs:element minOccurs="0" name="pipelineVariable" type="xs:string"/&gt;
      &lt;xs:element minOccurs="0" name="pluginVariable" type="xs:string"/&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;

  &lt;xs:complexType name="WSTypedContent"&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element minOccurs="0" name="contentType" type="xs:string"/&gt;
      &lt;xs:element minOccurs="0" name="url" type="xs:string"/&gt;
      &lt;xs:element minOccurs="0" name="wsBytes" type="tns:WSByteArray"/&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;

  &lt;xs:complexType name="WSByteArray"&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element minOccurs="0" name="bytes" type="xs:base64Binary"/&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;

  &lt;xs:complexType name="existsTransformerPluginV2"&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element minOccurs="0" name="arg0" type="tns:WSExistsTransformerPluginV2"/&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;

  &lt;xs:complexType name="WSExistsTransformerPluginV2"&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element minOccurs="0" name="jndiName" type="xs:string"/&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;

  &lt;xs:complexType name="existsTransformerPluginV2Response"&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element minOccurs="0" name="return" type="tns:WSBoolean"/&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;

  &lt;xs:complexType name="deleteBusinessConcept"&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element minOccurs="0" name="arg0" type="tns:WSDeleteBusinessConcept"/&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;

  &lt;xs:complexType name="WSDeleteBusinessConcept"&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element minOccurs="0" name="businessConceptName" type="xs:string"/&gt;
      &lt;xs:element minOccurs="0" name="wsDataModelPK" type="tns:WSDataModelPK"/&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;

  &lt;xs:complexType name="deleteBusinessConceptResponse"&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element minOccurs="0" name="return" type="tns:WSString"/&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;

  &lt;xs:complexType name="putItemArray"&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element minOccurs="0" name="arg0" type="tns:WSPutItemArray"/&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;

  &lt;xs:complexType name="WSPutItemArray"&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element maxOccurs="unbounded" minOccurs="0" name="wsPutItem" nillable="true" type="tns:WSPutItem"/&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;

  &lt;xs:complexType name="putItemArrayResponse"&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element minOccurs="0" name="return" type="tns:WSItemPKArray"/&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;

  &lt;xs:complexType name="executeRoutingOrderV2Synchronously"&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element minOccurs="0" name="arg0" type="tns:WSExecuteRoutingOrderV2Synchronously"/&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;

  &lt;xs:complexType name="WSExecuteRoutingOrderV2Synchronously"&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element minOccurs="0" name="routingOrderV2PK" type="tns:WSRoutingOrderV2PK"/&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;

  &lt;xs:complexType name="WSRoutingOrderV2PK"&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element minOccurs="0" name="name" type="xs:string"/&gt;
      &lt;xs:element minOccurs="0" name="status" type="tns:WSRoutingOrderV2Status"/&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;

  &lt;xs:complexType name="executeRoutingOrderV2SynchronouslyResponse"&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element minOccurs="0" name="return" type="tns:WSString"/&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;

  &lt;xs:complexType name="getMenu"&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element minOccurs="0" name="arg0" type="tns:WSGetMenu"/&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;

  &lt;xs:complexType name="WSGetMenu"&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element minOccurs="0" name="wsMenuPK" type="tns:WSMenuPK"/&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;

  &lt;xs:complexType name="WSMenuPK"&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element minOccurs="0" name="pk" type="xs:string"/&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;

  &lt;xs:complexType name="getMenuResponse"&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element minOccurs="0" name="return" type="tns:WSMenu"/&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;

  &lt;xs:complexType name="WSMenu"&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element minOccurs="0" name="description" type="xs:string"/&gt;
      &lt;xs:element maxOccurs="unbounded" minOccurs="0" name="menuEntries" nillable="true" type="tns:WSMenuEntry"/&gt;
      &lt;xs:element minOccurs="0" name="name" type="xs:string"/&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;

  &lt;xs:complexType name="WSMenuEntry"&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element minOccurs="0" name="application" type="xs:string"/&gt;
      &lt;xs:element minOccurs="0" name="context" type="xs:string"/&gt;
      &lt;xs:element maxOccurs="unbounded" minOccurs="0" name="descriptions" nillable="true" type="tns:WSMenuMenuEntriesDescriptions"/&gt;
      &lt;xs:element minOccurs="0" name="icon" type="xs:string"/&gt;
      &lt;xs:element minOccurs="0" name="id" type="xs:string"/&gt;
      &lt;xs:element maxOccurs="unbounded" minOccurs="0" name="subMenus" nillable="true" type="tns:WSMenuEntry"/&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;

  &lt;xs:complexType name="WSMenuMenuEntriesDescriptions"&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element minOccurs="0" name="label" type="xs:string"/&gt;
      &lt;xs:element minOccurs="0" name="language" type="xs:string"/&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;

  &lt;xs:complexType name="viewSearch"&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element minOccurs="0" name="arg0" type="tns:WSViewSearch"/&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;

  &lt;xs:complexType name="WSViewSearch"&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element minOccurs="0" name="direction" type="xs:string"/&gt;
      &lt;xs:element name="maxItems" type="xs:int"/&gt;
      &lt;xs:element minOccurs="0" name="orderBy" type="xs:string"/&gt;
      &lt;xs:element name="skip" type="xs:int"/&gt;
      &lt;xs:element name="spellTreshold" type="xs:int"/&gt;
      &lt;xs:element minOccurs="0" name="whereItem" type="tns:WSWhereItem"/&gt;
      &lt;xs:element minOccurs="0" name="wsDataClusterPK" type="tns:WSDataClusterPK"/&gt;
      &lt;xs:element minOccurs="0" name="wsViewPK" type="tns:WSViewPK"/&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;

  &lt;xs:complexType name="WSViewPK"&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element minOccurs="0" name="pk" type="xs:string"/&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;

  &lt;xs:complexType name="viewSearchResponse"&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element minOccurs="0" name="return" type="tns:WSStringArray"/&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;

  &lt;xs:complexType name="WSStringArray"&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element maxOccurs="unbounded" minOccurs="0" name="strings" nillable="true" type="xs:string"/&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;

  &lt;xs:complexType name="getItemsByCustomFKFilters"&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element minOccurs="0" name="arg0" type="tns:WSGetItemsByCustomFKFilters"/&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;

  &lt;xs:complexType name="WSGetItemsByCustomFKFilters"&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element minOccurs="0" name="conceptName" type="xs:string"/&gt;
      &lt;xs:element minOccurs="0" name="direction" type="xs:string"/&gt;
      &lt;xs:element minOccurs="0" name="injectedXpath" type="xs:string"/&gt;
      &lt;xs:element name="maxItems" type="xs:int"/&gt;
      &lt;xs:element minOccurs="0" name="orderBy" type="xs:string"/&gt;
      &lt;xs:element name="returnCount" type="xs:boolean"/&gt;
      &lt;xs:element name="skip" type="xs:int"/&gt;
      &lt;xs:element minOccurs="0" name="viewablePaths" type="tns:WSStringArray"/&gt;
      &lt;xs:element minOccurs="0" name="whereItem" type="tns:WSWhereItem"/&gt;
      &lt;xs:element minOccurs="0" name="wsDataClusterPK" type="tns:WSDataClusterPK"/&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;

  &lt;xs:complexType name="getItemsByCustomFKFiltersResponse"&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element minOccurs="0" name="return" type="tns:WSStringArray"/&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;

  &lt;xs:complexType name="supportStaging"&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element minOccurs="0" name="arg0" type="tns:WSDataClusterPK"/&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;

  &lt;xs:complexType name="supportStagingResponse"&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element minOccurs="0" name="return" type="tns:WSBoolean"/&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;

  &lt;xs:complexType name="processBytesUsingTransformer"&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element minOccurs="0" name="arg0" type="tns:WSProcessBytesUsingTransformer"/&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;

  &lt;xs:complexType name="WSProcessBytesUsingTransformer"&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element minOccurs="0" name="contentType" type="xs:string"/&gt;
      &lt;xs:element minOccurs="0" name="wsBytes" type="tns:WSByteArray"/&gt;
      &lt;xs:element minOccurs="0" name="wsOutputDecisionTable" type="tns:WSOutputDecisionTable"/&gt;
      &lt;xs:element minOccurs="0" name="wsTransformerPK" type="tns:WSTransformerPK"/&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;

  &lt;xs:complexType name="WSOutputDecisionTable"&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element maxOccurs="unbounded" minOccurs="0" name="decisions" nillable="true" type="tns:WSProcessBytesUsingTransformerWsOutputDecisionTableDecisions"/&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;

  &lt;xs:complexType name="WSProcessBytesUsingTransformerWsOutputDecisionTableDecisions"&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element minOccurs="0" name="decision" type="xs:string"/&gt;
      &lt;xs:element minOccurs="0" name="outputVariableName" type="xs:string"/&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;

  &lt;xs:complexType name="WSTransformerPK"&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element minOccurs="0" name="pk" type="xs:string"/&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;

  &lt;xs:complexType name="processBytesUsingTransformerResponse"&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element minOccurs="0" name="return" type="tns:WSPipeline"/&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;

  &lt;xs:complexType name="WSPipeline"&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element maxOccurs="unbounded" minOccurs="0" name="typedContentEntry" nillable="true" type="tns:WSPipelineTypedContentEntry"/&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;

  &lt;xs:complexType name="WSPipelineTypedContentEntry"&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element minOccurs="0" name="output" type="xs:string"/&gt;
      &lt;xs:element minOccurs="0" name="wsExtractedContent" type="tns:WSExtractedContent"/&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;

  &lt;xs:complexType name="WSExtractedContent"&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element minOccurs="0" name="contentType" type="xs:string"/&gt;
      &lt;xs:element minOccurs="0" name="wsByteArray" type="tns:WSByteArray"/&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;

  &lt;xs:complexType name="deleteItem"&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element minOccurs="0" name="arg0" type="tns:WSDeleteItem"/&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;

  &lt;xs:complexType name="WSDeleteItem"&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element minOccurs="0" name="invokeBeforeDeleting" type="xs:boolean"/&gt;
      &lt;xs:element minOccurs="0" name="override" type="xs:boolean"/&gt;
      &lt;xs:element minOccurs="0" name="source" type="xs:string"/&gt;
      &lt;xs:element minOccurs="0" name="withReport" type="xs:boolean"/&gt;
      &lt;xs:element minOccurs="0" name="wsItemPK" type="tns:WSItemPK"/&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;

  &lt;xs:complexType name="deleteItemResponse"&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element minOccurs="0" name="return" type="tns:WSItemPK"/&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;

  &lt;xs:complexType name="checkFKIntegrity"&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element minOccurs="0" name="arg0" type="tns:WSDeleteItem"/&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;

  &lt;xs:complexType name="checkFKIntegrityResponse"&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element minOccurs="0" name="return" type="tns:fkIntegrityCheckResult"/&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;

  &lt;xs:complexType name="executeTransformerV2"&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element minOccurs="0" name="arg0" type="tns:WSExecuteTransformerV2"/&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;

  &lt;xs:complexType name="WSExecuteTransformerV2"&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element minOccurs="0" name="wsTransformerContext" type="tns:WSTransformerContext"/&gt;
      &lt;xs:element minOccurs="0" name="wsTypedContent" type="tns:WSTypedContent"/&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;

  &lt;xs:complexType name="WSTransformerContext"&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element minOccurs="0" name="pipeline" type="tns:WSTransformerContextPipeline"/&gt;
      &lt;xs:element minOccurs="0" name="projectedItemPKs" type="tns:WSTransformerContextProjectedItemPKs"/&gt;
      &lt;xs:element minOccurs="0" name="wsTransformerPK" type="tns:WSTransformerV2PK"/&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;

  &lt;xs:complexType name="WSTransformerContextPipeline"&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element maxOccurs="unbounded" minOccurs="0" name="pipelineItem" nillable="true" type="tns:WSTransformerContextPipelinePipelineItem"/&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;

  &lt;xs:complexType name="WSTransformerContextPipelinePipelineItem"&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element minOccurs="0" name="variable" type="xs:string"/&gt;
      &lt;xs:element minOccurs="0" name="wsTypedContent" type="tns:WSTypedContent"/&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;

  &lt;xs:complexType name="WSTransformerContextProjectedItemPKs"&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element maxOccurs="unbounded" minOccurs="0" name="wsItemPOJOPK" nillable="true" type="tns:WSItemPK"/&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;

  &lt;xs:complexType name="executeTransformerV2Response"&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element minOccurs="0" name="return" type="tns:WSTransformerContext"/&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;

  &lt;xs:complexType name="putView"&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element minOccurs="0" name="arg0" type="tns:WSPutView"/&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;

  &lt;xs:complexType name="WSPutView"&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element minOccurs="0" name="wsView" type="tns:WSView"/&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;

  &lt;xs:complexType name="WSView"&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element minOccurs="0" name="description" type="xs:string"/&gt;
      &lt;xs:element minOccurs="0" name="isTransformerActive" type="tns:WSBoolean"/&gt;
      &lt;xs:element minOccurs="0" name="name" type="xs:string"/&gt;
      &lt;xs:element maxOccurs="unbounded" minOccurs="0" name="searchableBusinessElements" nillable="true" type="xs:string"/&gt;
      &lt;xs:element minOccurs="0" name="transformerPK" type="xs:string"/&gt;
      &lt;xs:element maxOccurs="unbounded" minOccurs="0" name="viewableBusinessElements" nillable="true" type="xs:string"/&gt;
      &lt;xs:element maxOccurs="unbounded" minOccurs="0" name="whereConditions" nillable="true" type="tns:WSWhereCondition"/&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;

  &lt;xs:complexType name="putViewResponse"&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element minOccurs="0" name="return" type="tns:WSViewPK"/&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;

  &lt;xs:complexType name="getTransformerPKs"&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element minOccurs="0" name="arg0" type="tns:WSGetTransformerPKs"/&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;

  &lt;xs:complexType name="WSGetTransformerPKs"&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element minOccurs="0" name="regex" type="xs:string"/&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;

  &lt;xs:complexType name="getTransformerPKsResponse"&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element minOccurs="0" name="return" type="tns:WSTransformerPKArray"/&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;

  &lt;xs:complexType name="WSTransformerPKArray"&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element maxOccurs="unbounded" minOccurs="0" name="wsTransformerPK" nillable="true" type="tns:WSTransformerPK"/&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;

  &lt;xs:complexType name="existsStoredProcedure"&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element minOccurs="0" name="arg0" type="tns:WSExistsStoredProcedure"/&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;

  &lt;xs:complexType name="WSExistsStoredProcedure"&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element minOccurs="0" name="wsStoredProcedurePK" type="tns:WSStoredProcedurePK"/&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;

  &lt;xs:complexType name="existsStoredProcedureResponse"&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element minOccurs="0" name="return" type="tns:WSBoolean"/&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;

  &lt;xs:complexType name="putStoredProcedure"&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element minOccurs="0" name="arg0" type="tns:WSPutStoredProcedure"/&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;

  &lt;xs:complexType name="WSPutStoredProcedure"&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element minOccurs="0" name="wsStoredProcedure" type="tns:WSStoredProcedure"/&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;

  &lt;xs:complexType name="WSStoredProcedure"&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element minOccurs="0" name="description" type="xs:string"/&gt;
      &lt;xs:element minOccurs="0" name="name" type="xs:string"/&gt;
      &lt;xs:element minOccurs="0" name="procedure" type="xs:string"/&gt;
      &lt;xs:element minOccurs="0" name="refreshCache" type="xs:boolean"/&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;

  &lt;xs:complexType name="putStoredProcedureResponse"&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element minOccurs="0" name="return" type="tns:WSStoredProcedurePK"/&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;

  &lt;xs:complexType name="existsMenu"&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element minOccurs="0" name="arg0" type="tns:WSExistsMenu"/&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;

  &lt;xs:complexType name="WSExistsMenu"&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element minOccurs="0" name="wsMenuPK" type="tns:WSMenuPK"/&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;

  &lt;xs:complexType name="existsMenuResponse"&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element minOccurs="0" name="return" type="tns:WSBoolean"/&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;

  &lt;xs:complexType name="getComponentVersion"&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element minOccurs="0" name="arg0" type="tns:WSGetComponentVersion"/&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;

  &lt;xs:complexType name="WSGetComponentVersion"&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element minOccurs="0" name="component" type="tns:WSComponent"/&gt;
      &lt;xs:element minOccurs="0" name="id" type="xs:string"/&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;

  &lt;xs:complexType name="getComponentVersionResponse"&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element minOccurs="0" name="return" type="tns:WSVersion"/&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;

  &lt;xs:complexType name="WSVersion"&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element minOccurs="0" name="build" type="xs:string"/&gt;
      &lt;xs:element minOccurs="0" name="date" type="xs:string"/&gt;
      &lt;xs:element minOccurs="0" name="description" type="xs:string"/&gt;
      &lt;xs:element name="major" type="xs:int"/&gt;
      &lt;xs:element name="minor" type="xs:int"/&gt;
      &lt;xs:element name="revision" type="xs:int"/&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;

  &lt;xs:complexType name="putDBDataCluster"&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element minOccurs="0" name="arg0" type="tns:WSPutDBDataCluster"/&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;

  &lt;xs:complexType name="WSPutDBDataCluster"&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element minOccurs="0" name="name" type="xs:string"/&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;

  &lt;xs:complexType name="putDBDataClusterResponse"&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element minOccurs="0" name="return" type="tns:WSBoolean"/&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;

  &lt;xs:complexType name="getBusinessConceptKey"&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element minOccurs="0" name="arg0" type="tns:WSGetBusinessConceptKey"/&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;

  &lt;xs:complexType name="WSGetBusinessConceptKey"&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element minOccurs="0" name="concept" type="xs:string"/&gt;
      &lt;xs:element minOccurs="0" name="wsDataModelPK" type="tns:WSDataModelPK"/&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;

  &lt;xs:complexType name="getBusinessConceptKeyResponse"&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element minOccurs="0" name="return" type="tns:WSConceptKey"/&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;

  &lt;xs:complexType name="WSConceptKey"&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element maxOccurs="unbounded" minOccurs="0" name="fields" nillable="true" type="xs:string"/&gt;
      &lt;xs:element minOccurs="0" name="selector" type="xs:string"/&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;

  &lt;xs:complexType name="getRoutingOrderV2SByCriteria"&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element minOccurs="0" name="arg0" type="tns:WSGetRoutingOrderV2SByCriteria"/&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;

  &lt;xs:complexType name="WSGetRoutingOrderV2SByCriteria"&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element minOccurs="0" name="wsSearchCriteria" type="tns:WSRoutingOrderV2SearchCriteria"/&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;

  &lt;xs:complexType name="WSRoutingOrderV2SearchCriteria"&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element minOccurs="0" name="anyFieldContains" type="xs:string"/&gt;
      &lt;xs:element minOccurs="0" name="itemPKConceptContains" type="xs:string"/&gt;
      &lt;xs:element minOccurs="0" name="itemPKIDFieldsContain" type="xs:string"/&gt;
      &lt;xs:element minOccurs="0" name="messageContain" type="xs:string"/&gt;
      &lt;xs:element minOccurs="0" name="nameContains" type="xs:string"/&gt;
      &lt;xs:element minOccurs="0" name="serviceJNDIContains" type="xs:string"/&gt;
      &lt;xs:element minOccurs="0" name="serviceParametersContain" type="xs:string"/&gt;
      &lt;xs:element minOccurs="0" name="status" type="tns:WSRoutingOrderV2Status"/&gt;
      &lt;xs:element name="timeCreatedMax" type="xs:long"/&gt;
      &lt;xs:element name="timeCreatedMin" type="xs:long"/&gt;
      &lt;xs:element name="timeLastRunCompletedMax" type="xs:long"/&gt;
      &lt;xs:element name="timeLastRunCompletedMin" type="xs:long"/&gt;
      &lt;xs:element name="timeLastRunStartedMax" type="xs:long"/&gt;
      &lt;xs:element name="timeLastRunStartedMin" type="xs:long"/&gt;
      &lt;xs:element name="timeScheduledMax" type="xs:long"/&gt;
      &lt;xs:element name="timeScheduledMin" type="xs:long"/&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;

  &lt;xs:complexType name="getRoutingOrderV2SByCriteriaResponse"&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element minOccurs="0" name="return" type="tns:WSRoutingOrderV2Array"/&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;

  &lt;xs:complexType name="WSRoutingOrderV2Array"&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element maxOccurs="unbounded" minOccurs="0" name="wsRoutingOrder" nillable="true" type="tns:WSRoutingOrderV2"/&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;

  &lt;xs:complexType name="WSRoutingOrderV2"&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element minOccurs="0" name="bindingUniverseName" type="xs:string"/&gt;
      &lt;xs:element minOccurs="0" name="bindingUserToken" type="xs:string"/&gt;
      &lt;xs:element minOccurs="0" name="message" type="xs:string"/&gt;
      &lt;xs:element minOccurs="0" name="name" type="xs:string"/&gt;
      &lt;xs:element minOccurs="0" name="serviceJNDI" type="xs:string"/&gt;
      &lt;xs:element minOccurs="0" name="serviceParameters" type="xs:string"/&gt;
      &lt;xs:element minOccurs="0" name="status" type="tns:WSRoutingOrderV2Status"/&gt;
      &lt;xs:element name="timeCreated" type="xs:long"/&gt;
      &lt;xs:element name="timeLastRunCompleted" type="xs:long"/&gt;
      &lt;xs:element name="timeLastRunStarted" type="xs:long"/&gt;
      &lt;xs:element name="timeScheduled" type="xs:long"/&gt;
      &lt;xs:element minOccurs="0" name="wsItemPK" type="tns:WSItemPK"/&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;

  &lt;xs:complexType name="deleteMenu"&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element minOccurs="0" name="arg0" type="tns:WSDeleteMenu"/&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;

  &lt;xs:complexType name="WSDeleteMenu"&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element minOccurs="0" name="wsMenuPK" type="tns:WSMenuPK"/&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;

  &lt;xs:complexType name="deleteMenuResponse"&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element minOccurs="0" name="return" type="tns:WSMenuPK"/&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;

  &lt;xs:complexType name="getBackgroundJob"&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element minOccurs="0" name="arg0" type="tns:WSGetBackgroundJob"/&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;

  &lt;xs:complexType name="WSGetBackgroundJob"&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element minOccurs="0" name="pk" type="xs:string"/&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;

  &lt;xs:complexType name="getBackgroundJobResponse"&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element minOccurs="0" name="return" type="tns:WSBackgroundJob"/&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;

  &lt;xs:complexType name="WSBackgroundJob"&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element minOccurs="0" name="description" type="xs:string"/&gt;
      &lt;xs:element minOccurs="0" name="id" type="xs:string"/&gt;
      &lt;xs:element minOccurs="0" name="message" type="xs:string"/&gt;
      &lt;xs:element minOccurs="0" name="percentage" type="xs:int"/&gt;
      &lt;xs:element minOccurs="0" name="pipeline" type="tns:WSPipeline"/&gt;
      &lt;xs:element minOccurs="0" name="serializedObject" type="xs:base64Binary"/&gt;
      &lt;xs:element minOccurs="0" name="status" type="tns:BackgroundJobStatusType"/&gt;
      &lt;xs:element minOccurs="0" name="timestamp" type="xs:string"/&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;

  &lt;xs:complexType name="putItemWithCustomReport"&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element minOccurs="0" name="arg0" type="tns:WSPutItemWithCustomReport"/&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;

  &lt;xs:complexType name="WSPutItemWithCustomReport"&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element minOccurs="0" name="user" type="xs:string"/&gt;
      &lt;xs:element minOccurs="0" name="wsPutItemWithReport" type="tns:WSPutItemWithReport"/&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;

  &lt;xs:complexType name="putItemWithCustomReportResponse"&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element minOccurs="0" name="return" type="tns:WSItemPK"/&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;

  &lt;xs:complexType name="getServiceDocument"&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element minOccurs="0" name="arg0" type="tns:WSString"/&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;

  &lt;xs:complexType name="getServiceDocumentResponse"&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element minOccurs="0" name="return" type="tns:WSServiceGetDocument"/&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;

  &lt;xs:complexType name="WSServiceGetDocument"&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element minOccurs="0" name="configure" type="xs:string"/&gt;
      &lt;xs:element minOccurs="0" name="configureSchema" type="xs:string"/&gt;
      &lt;xs:element minOccurs="0" name="defaultConfig" type="xs:string"/&gt;
      &lt;xs:element minOccurs="0" name="description" type="xs:string"/&gt;
      &lt;xs:element minOccurs="0" name="document" type="xs:string"/&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;

  &lt;xs:complexType name="isItemModifiedByOther"&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element minOccurs="0" name="arg0" type="tns:WSIsItemModifiedByOther"/&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;

  &lt;xs:complexType name="WSIsItemModifiedByOther"&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element minOccurs="0" name="wsItem" type="tns:WSItem"/&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;

  &lt;xs:complexType name="WSItem"&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element minOccurs="0" name="conceptName" type="xs:string"/&gt;
      &lt;xs:element minOccurs="0" name="content" type="xs:string"/&gt;
      &lt;xs:element minOccurs="0" name="dataModelName" type="xs:string"/&gt;
      &lt;xs:element maxOccurs="unbounded" minOccurs="0" name="ids" nillable="true" type="xs:string"/&gt;
      &lt;xs:element name="insertionTime" type="xs:long"/&gt;
      &lt;xs:element minOccurs="0" name="taskId" type="xs:string"/&gt;
      &lt;xs:element minOccurs="0" name="wsDataClusterPK" type="tns:WSDataClusterPK"/&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;

  &lt;xs:complexType name="isItemModifiedByOtherResponse"&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element minOccurs="0" name="return" type="tns:WSBoolean"/&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;

  &lt;xs:complexType name="getRoutingRule"&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element minOccurs="0" name="arg0" type="tns:WSGetRoutingRule"/&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;

  &lt;xs:complexType name="WSGetRoutingRule"&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element minOccurs="0" name="wsRoutingRulePK" type="tns:WSRoutingRulePK"/&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;

  &lt;xs:complexType name="WSRoutingRulePK"&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element minOccurs="0" name="pk" type="xs:string"/&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;

  &lt;xs:complexType name="getRoutingRuleResponse"&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element minOccurs="0" name="return" type="tns:WSRoutingRule"/&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;

  &lt;xs:complexType name="WSRoutingRule"&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element minOccurs="0" name="concept" type="xs:string"/&gt;
      &lt;xs:element minOccurs="0" name="condition" type="xs:string"/&gt;
      &lt;xs:element minOccurs="0" name="deactive" type="xs:boolean"/&gt;
      &lt;xs:element minOccurs="0" name="description" type="xs:string"/&gt;
      &lt;xs:element name="executeOrder" type="xs:int"/&gt;
      &lt;xs:element minOccurs="0" name="name" type="xs:string"/&gt;
      &lt;xs:element minOccurs="0" name="parameters" type="xs:string"/&gt;
      &lt;xs:element minOccurs="0" name="serviceJNDI" type="xs:string"/&gt;
      &lt;xs:element name="synchronous" type="xs:boolean"/&gt;
      &lt;xs:element maxOccurs="unbounded" minOccurs="0" name="wsRoutingRuleExpressions" nillable="true" type="tns:WSRoutingRuleExpression"/&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;

  &lt;xs:complexType name="WSRoutingRuleExpression"&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element minOccurs="0" name="name" type="xs:string"/&gt;
      &lt;xs:element minOccurs="0" name="value" type="xs:string"/&gt;
      &lt;xs:element minOccurs="0" name="wsOperator" type="tns:WSRoutingRuleOperator"/&gt;
      &lt;xs:element minOccurs="0" name="xpath" type="xs:string"/&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;

  &lt;xs:complexType name="deleteRole"&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element minOccurs="0" name="arg0" type="tns:WSDeleteRole"/&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;

  &lt;xs:complexType name="WSDeleteRole"&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element minOccurs="0" name="wsRolePK" type="tns:WSRolePK"/&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;

  &lt;xs:complexType name="WSRolePK"&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element minOccurs="0" name="pk" type="xs:string"/&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;

  &lt;xs:complexType name="deleteRoleResponse"&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element minOccurs="0" name="return" type="tns:WSRolePK"/&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;

  &lt;xs:complexType name="putItem"&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element minOccurs="0" name="arg0" type="tns:WSPutItem"/&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;

  &lt;xs:complexType name="putItemResponse"&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element minOccurs="0" name="return" type="tns:WSItemPK"/&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;

  &lt;xs:complexType name="getItemsSort"&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element minOccurs="0" name="arg0" type="tns:WSGetItemsSort"/&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;

  &lt;xs:complexType name="WSGetItemsSort"&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element minOccurs="0" name="conceptName" type="xs:string"/&gt;
      &lt;xs:element minOccurs="0" name="dir" type="xs:string"/&gt;
      &lt;xs:element name="maxItems" type="xs:int"/&gt;
      &lt;xs:element name="skip" type="xs:int"/&gt;
      &lt;xs:element minOccurs="0" name="sort" type="xs:string"/&gt;
      &lt;xs:element name="spellTreshold" type="xs:int"/&gt;
      &lt;xs:element minOccurs="0" name="totalCountOnFirstResult" type="xs:boolean"/&gt;
      &lt;xs:element minOccurs="0" name="whereItem" type="tns:WSWhereItem"/&gt;
      &lt;xs:element minOccurs="0" name="wsDataClusterPK" type="tns:WSDataClusterPK"/&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;

  &lt;xs:complexType name="getItemsSortResponse"&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element minOccurs="0" name="return" type="tns:WSStringArray"/&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;

  &lt;xs:complexType name="getDataCluster"&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element minOccurs="0" name="arg0" type="tns:WSGetDataCluster"/&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;

  &lt;xs:complexType name="WSGetDataCluster"&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element minOccurs="0" name="wsDataClusterPK" type="tns:WSDataClusterPK"/&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;

  &lt;xs:complexType name="getDataClusterResponse"&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element minOccurs="0" name="return" type="tns:WSDataCluster"/&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;

  &lt;xs:complexType name="WSDataCluster"&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element minOccurs="0" name="description" type="xs:string"/&gt;
      &lt;xs:element minOccurs="0" name="name" type="xs:string"/&gt;
      &lt;xs:element minOccurs="0" name="vocabulary" type="xs:string"/&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;

  &lt;xs:complexType name="existsRole"&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element minOccurs="0" name="arg0" type="tns:WSExistsRole"/&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;

  &lt;xs:complexType name="WSExistsRole"&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element minOccurs="0" name="wsRolePK" type="tns:WSRolePK"/&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;

  &lt;xs:complexType name="existsRoleResponse"&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element minOccurs="0" name="return" type="tns:WSBoolean"/&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;

  &lt;xs:complexType name="getDigest"&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element minOccurs="0" name="arg0" type="tns:WSDigestKey"/&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;

  &lt;xs:complexType name="WSDigestKey"&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element minOccurs="0" name="objectName" type="xs:string"/&gt;
      &lt;xs:element minOccurs="0" name="type" type="xs:string"/&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;

  &lt;xs:complexType name="getDigestResponse"&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element minOccurs="0" name="return" type="tns:WSDigest"/&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;

  &lt;xs:complexType name="WSDigest"&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element minOccurs="0" name="digestValue" type="xs:string"/&gt;
      &lt;xs:element name="timeStamp" type="xs:long"/&gt;
      &lt;xs:element minOccurs="0" name="wsDigestKey" type="tns:WSDigestKey"/&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;

  &lt;xs:complexType name="getRoutingRulePKs"&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element minOccurs="0" name="arg0" type="tns:WSGetRoutingRulePKs"/&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;

  &lt;xs:complexType name="WSGetRoutingRulePKs"&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element minOccurs="0" name="regex" type="xs:string"/&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;

  &lt;xs:complexType name="getRoutingRulePKsResponse"&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element minOccurs="0" name="return" type="tns:WSRoutingRulePKArray"/&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;

  &lt;xs:complexType name="WSRoutingRulePKArray"&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element maxOccurs="unbounded" minOccurs="0" name="wsRoutingRulePKs" nillable="true" type="tns:WSRoutingRulePK"/&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;

  &lt;xs:complexType name="updateItemMetadata"&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element minOccurs="0" name="arg0" type="tns:WSUpdateMetadataItem"/&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;

  &lt;xs:complexType name="WSUpdateMetadataItem"&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element minOccurs="0" name="taskId" type="xs:string"/&gt;
      &lt;xs:element minOccurs="0" name="wsItemPK" type="tns:WSItemPK"/&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;

  &lt;xs:complexType name="updateItemMetadataResponse"&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element minOccurs="0" name="return" type="tns:WSItemPK"/&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;

  &lt;xs:complexType name="getBusinessConcepts"&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element minOccurs="0" name="arg0" type="tns:WSGetBusinessConcepts"/&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;

  &lt;xs:complexType name="WSGetBusinessConcepts"&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element minOccurs="0" name="wsDataModelPK" type="tns:WSDataModelPK"/&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;

  &lt;xs:complexType name="getBusinessConceptsResponse"&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element minOccurs="0" name="return" type="tns:WSStringArray"/&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;

  &lt;xs:complexType name="quickSearch"&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element minOccurs="0" name="arg0" type="tns:WSQuickSearch"/&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;

  &lt;xs:complexType name="WSQuickSearch"&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element minOccurs="0" name="direction" type="xs:string"/&gt;
      &lt;xs:element name="matchAllWords" type="xs:boolean"/&gt;
      &lt;xs:element name="maxItems" type="xs:int"/&gt;
      &lt;xs:element minOccurs="0" name="orderBy" type="xs:string"/&gt;
      &lt;xs:element minOccurs="0" name="searchedValue" type="xs:string"/&gt;
      &lt;xs:element name="skip" type="xs:int"/&gt;
      &lt;xs:element name="spellTreshold" type="xs:int"/&gt;
      &lt;xs:element minOccurs="0" name="wsDataClusterPK" type="tns:WSDataClusterPK"/&gt;
      &lt;xs:element minOccurs="0" name="wsViewPK" type="tns:WSViewPK"/&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;

  &lt;xs:complexType name="quickSearchResponse"&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element minOccurs="0" name="return" type="tns:WSStringArray"/&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;

  &lt;xs:complexType name="processBytesUsingTransformerAsBackgroundJob"&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element minOccurs="0" name="arg0" type="tns:WSProcessBytesUsingTransformerAsBackgroundJob"/&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;

  &lt;xs:complexType name="WSProcessBytesUsingTransformerAsBackgroundJob"&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element minOccurs="0" name="contentType" type="xs:string"/&gt;
      &lt;xs:element minOccurs="0" name="wsBytes" type="tns:WSByteArray"/&gt;
      &lt;xs:element minOccurs="0" name="wsOutputDecisionTable" type="tns:WSOutputDecisionTable"/&gt;
      &lt;xs:element minOccurs="0" name="wsTransformerPK" type="tns:WSTransformerPK"/&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;

  &lt;xs:complexType name="processBytesUsingTransformerAsBackgroundJobResponse"&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element minOccurs="0" name="return" type="tns:WSBackgroundJobPK"/&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;

  &lt;xs:complexType name="getStoredProcedurePKs"&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element minOccurs="0" name="arg0" type="tns:WSRegexStoredProcedure"/&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;

  &lt;xs:complexType name="WSRegexStoredProcedure"&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element minOccurs="0" name="regex" type="xs:string"/&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;

  &lt;xs:complexType name="getStoredProcedurePKsResponse"&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element minOccurs="0" name="return" type="tns:WSStoredProcedurePKArray"/&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;

  &lt;xs:complexType name="WSStoredProcedurePKArray"&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element maxOccurs="unbounded" minOccurs="0" name="wsStoredProcedurePK" nillable="true" type="tns:WSStoredProcedurePK"/&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;

  &lt;xs:complexType name="putTransformer"&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element minOccurs="0" name="arg0" type="tns:WSPutTransformer"/&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;

  &lt;xs:complexType name="WSPutTransformer"&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element minOccurs="0" name="wsTransformer" type="tns:WSTransformer"/&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;

  &lt;xs:complexType name="WSTransformer"&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element minOccurs="0" name="description" type="xs:string"/&gt;
      &lt;xs:element minOccurs="0" name="name" type="xs:string"/&gt;
      &lt;xs:element maxOccurs="unbounded" minOccurs="0" name="pluginSpecs" nillable="true" type="tns:WSTransformerPluginSpec"/&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;

  &lt;xs:complexType name="WSTransformerPluginSpec"&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element minOccurs="0" name="description" type="xs:string"/&gt;
      &lt;xs:element minOccurs="0" name="input" type="xs:string"/&gt;
      &lt;xs:element minOccurs="0" name="output" type="xs:string"/&gt;
      &lt;xs:element minOccurs="0" name="parameters" type="xs:string"/&gt;
      &lt;xs:element minOccurs="0" name="pluginJNDI" type="xs:string"/&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;

  &lt;xs:complexType name="putTransformerResponse"&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element minOccurs="0" name="return" type="tns:WSTransformerPK"/&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;

  &lt;xs:complexType name="countItemsByCustomFKFilters"&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element minOccurs="0" name="arg0" type="tns:WSCountItemsByCustomFKFilters"/&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;

  &lt;xs:complexType name="WSCountItemsByCustomFKFilters"&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element minOccurs="0" name="conceptName" type="xs:string"/&gt;
      &lt;xs:element minOccurs="0" name="injectedXpath" type="xs:string"/&gt;
      &lt;xs:element minOccurs="0" name="wsDataClusterPK" type="tns:WSDataClusterPK"/&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;

  &lt;xs:complexType name="countItemsByCustomFKFiltersResponse"&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element minOccurs="0" name="return" type="tns:WSString"/&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;

  &lt;xs:complexType name="updateDigest"&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element minOccurs="0" name="arg0" type="tns:WSDigest"/&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;

  &lt;xs:complexType name="updateDigestResponse"&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element minOccurs="0" name="return" type="tns:WSLong"/&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;

  &lt;xs:complexType name="WSLong"&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element name="value" type="xs:long"/&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;

  &lt;xs:complexType name="getConceptsInDataCluster"&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element minOccurs="0" name="arg0" type="tns:WSGetConceptsInDataCluster"/&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;

  &lt;xs:complexType name="WSGetConceptsInDataCluster"&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element minOccurs="0" name="wsDataClusterPK" type="tns:WSDataClusterPK"/&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;

  &lt;xs:complexType name="getConceptsInDataClusterResponse"&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element minOccurs="0" name="return" type="tns:WSStringArray"/&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;

  &lt;xs:complexType name="processFileUsingTransformerAsBackgroundJob"&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element minOccurs="0" name="arg0" type="tns:WSProcessFileUsingTransformerAsBackgroundJob"/&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;

  &lt;xs:complexType name="WSProcessFileUsingTransformerAsBackgroundJob"&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element minOccurs="0" name="contentType" type="xs:string"/&gt;
      &lt;xs:element minOccurs="0" name="fileName" type="xs:string"/&gt;
      &lt;xs:element minOccurs="0" name="wsOutputDecisionTable" type="tns:WSOutputDecisionTable"/&gt;
      &lt;xs:element minOccurs="0" name="wsTransformerPK" type="tns:WSTransformerPK"/&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;

  &lt;xs:complexType name="processFileUsingTransformerAsBackgroundJobResponse"&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element minOccurs="0" name="return" type="tns:WSBackgroundJobPK"/&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;

  &lt;xs:complexType name="existsTransformer"&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element minOccurs="0" name="arg0" type="tns:WSExistsTransformer"/&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;

  &lt;xs:complexType name="WSExistsTransformer"&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element minOccurs="0" name="wsTransformerPK" type="tns:WSTransformerPK"/&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;

  &lt;xs:complexType name="existsTransformerResponse"&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element minOccurs="0" name="return" type="tns:WSBoolean"/&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;

  &lt;xs:complexType name="getDataModel"&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element minOccurs="0" name="arg0" type="tns:WSGetDataModel"/&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;

  &lt;xs:complexType name="WSGetDataModel"&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element minOccurs="0" name="wsDataModelPK" type="tns:WSDataModelPK"/&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;

  &lt;xs:complexType name="getDataModelResponse"&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element minOccurs="0" name="return" type="tns:WSDataModel"/&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;

  &lt;xs:complexType name="WSDataModel"&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element minOccurs="0" name="description" type="xs:string"/&gt;
      &lt;xs:element minOccurs="0" name="name" type="xs:string"/&gt;
      &lt;xs:element minOccurs="0" name="xsdSchema" type="xs:string"/&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;

  &lt;xs:complexType name="runQuery"&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element minOccurs="0" name="arg0" type="tns:WSRunQuery"/&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;

  &lt;xs:complexType name="WSRunQuery"&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element maxOccurs="unbounded" minOccurs="0" name="parameters" nillable="true" type="xs:string"/&gt;
      &lt;xs:element minOccurs="0" name="query" type="xs:string"/&gt;
      &lt;xs:element minOccurs="0" name="wsDataClusterPK" type="tns:WSDataClusterPK"/&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;

  &lt;xs:complexType name="runQueryResponse"&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element minOccurs="0" name="return" type="tns:WSStringArray"/&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;

  &lt;xs:complexType name="putBusinessConcept"&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element minOccurs="0" name="arg0" type="tns:WSPutBusinessConcept"/&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;

  &lt;xs:complexType name="WSPutBusinessConcept"&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element minOccurs="0" name="businessConcept" type="tns:WSBusinessConcept"/&gt;
      &lt;xs:element minOccurs="0" name="wsDataModelPK" type="tns:WSDataModelPK"/&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;

  &lt;xs:complexType name="WSBusinessConcept"&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element minOccurs="0" name="businessTemplate" type="xs:string"/&gt;
      &lt;xs:element minOccurs="0" name="name" type="xs:string"/&gt;
      &lt;xs:element maxOccurs="unbounded" minOccurs="0" name="wsDescription" nillable="true" type="tns:WSI18NString"/&gt;
      &lt;xs:element maxOccurs="unbounded" minOccurs="0" name="wsLabel" nillable="true" type="tns:WSI18NString"/&gt;
      &lt;xs:element minOccurs="0" name="wsUniqueKey" type="tns:WSKey"/&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;

  &lt;xs:complexType name="WSI18NString"&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element minOccurs="0" name="label" type="xs:string"/&gt;
      &lt;xs:element minOccurs="0" name="language" type="tns:WSLanguage"/&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;

  &lt;xs:complexType name="WSKey"&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element maxOccurs="unbounded" minOccurs="0" name="fieldpath" nillable="true" type="xs:string"/&gt;
      &lt;xs:element minOccurs="0" name="selectorpath" type="xs:string"/&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;

  &lt;xs:complexType name="putBusinessConceptResponse"&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element minOccurs="0" name="return" type="tns:WSString"/&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;

  &lt;xs:complexType name="logout"&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element minOccurs="0" name="arg0" type="tns:WSLogout"/&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;

  &lt;xs:complexType name="WSLogout"&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element minOccurs="0" name="dummy" type="xs:string"/&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;

  &lt;xs:complexType name="logoutResponse"&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element minOccurs="0" name="return" type="tns:WSString"/&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;

  &lt;xs:complexType name="existsView"&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element minOccurs="0" name="arg0" type="tns:WSExistsView"/&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;

  &lt;xs:complexType name="WSExistsView"&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element minOccurs="0" name="wsViewPK" type="tns:WSViewPK"/&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;

  &lt;xs:complexType name="existsViewResponse"&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element minOccurs="0" name="return" type="tns:WSBoolean"/&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;

  &lt;xs:complexType name="serviceAction"&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element minOccurs="0" name="arg0" type="tns:WSServiceAction"/&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;

  &lt;xs:complexType name="WSServiceAction"&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element minOccurs="0" name="jndiName" type="xs:string"/&gt;
      &lt;xs:element minOccurs="0" name="methodName" type="xs:string"/&gt;
      &lt;xs:element maxOccurs="unbounded" minOccurs="0" name="methodParameters" nillable="true" type="xs:string"/&gt;
      &lt;xs:element minOccurs="0" name="wsAction" type="tns:WSServiceActionCode"/&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;

  &lt;xs:complexType name="serviceActionResponse"&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element minOccurs="0" name="return" type="tns:WSString"/&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;

  &lt;xs:complexType name="getViewPKs"&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element minOccurs="0" name="arg0" type="tns:WSGetViewPKs"/&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;

  &lt;xs:complexType name="WSGetViewPKs"&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element minOccurs="0" name="regex" type="xs:string"/&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;

  &lt;xs:complexType name="getViewPKsResponse"&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element minOccurs="0" name="return" type="tns:WSViewPKArray"/&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;

  &lt;xs:complexType name="WSViewPKArray"&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element maxOccurs="unbounded" minOccurs="0" name="wsViewPK" nillable="true" type="tns:WSViewPK"/&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;

  &lt;xs:complexType name="executeStoredProcedure"&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element minOccurs="0" name="arg0" type="tns:WSExecuteStoredProcedure"/&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;

  &lt;xs:complexType name="WSExecuteStoredProcedure"&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element maxOccurs="unbounded" minOccurs="0" name="parameters" nillable="true" type="xs:string"/&gt;
      &lt;xs:element minOccurs="0" name="wsDataClusterPK" type="tns:WSDataClusterPK"/&gt;
      &lt;xs:element minOccurs="0" name="wsStoredProcedurePK" type="tns:WSStoredProcedurePK"/&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;

  &lt;xs:complexType name="executeStoredProcedureResponse"&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element minOccurs="0" name="return" type="tns:WSStringArray"/&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;

  &lt;xs:complexType name="deleteItemWithReport"&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element minOccurs="0" name="arg0" type="tns:WSDeleteItemWithReport"/&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;

  &lt;xs:complexType name="WSDeleteItemWithReport"&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element minOccurs="0" name="invokeBeforeSaving" type="xs:boolean"/&gt;
      &lt;xs:element minOccurs="0" name="operateType" type="xs:string"/&gt;
      &lt;xs:element minOccurs="0" name="override" type="xs:boolean"/&gt;
      &lt;xs:element minOccurs="0" name="pushToUpdateReport" type="xs:boolean"/&gt;
      &lt;xs:element minOccurs="0" name="source" type="xs:string"/&gt;
      &lt;xs:element minOccurs="0" name="updatePath" type="xs:string"/&gt;
      &lt;xs:element minOccurs="0" name="user" type="xs:string"/&gt;
      &lt;xs:element minOccurs="0" name="wsItemPK" type="tns:WSItemPK"/&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;

  &lt;xs:complexType name="deleteItemWithReportResponse"&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element minOccurs="0" name="return" type="tns:WSString"/&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;

  &lt;xs:complexType name="initMDM"&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element minOccurs="0" name="arg0" type="tns:WSInitData"/&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;

  &lt;xs:complexType name="WSInitData"&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element minOccurs="0" name="xmlSchema" type="xs:string"/&gt;
      &lt;xs:element name="zap" type="xs:boolean"/&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;

  &lt;xs:complexType name="initMDMResponse"&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element minOccurs="0" name="return" type="tns:WSInt"/&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;

  &lt;xs:complexType name="deleteRoutingOrderV2"&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element minOccurs="0" name="arg0" type="tns:WSDeleteRoutingOrderV2"/&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;

  &lt;xs:complexType name="WSDeleteRoutingOrderV2"&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element minOccurs="0" name="wsRoutingOrderPK" type="tns:WSRoutingOrderV2PK"/&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;

  &lt;xs:complexType name="deleteRoutingOrderV2Response"&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element minOccurs="0" name="return" type="tns:WSRoutingOrderV2PK"/&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;

  &lt;xs:complexType name="getStoredProcedure"&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element minOccurs="0" name="arg0" type="tns:WSGetStoredProcedure"/&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;

  &lt;xs:complexType name="WSGetStoredProcedure"&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element minOccurs="0" name="wsStoredProcedurePK" type="tns:WSStoredProcedurePK"/&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;

  &lt;xs:complexType name="getStoredProcedureResponse"&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element minOccurs="0" name="return" type="tns:WSStoredProcedure"/&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;

  &lt;xs:complexType name="getItemPKsByCriteria"&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element minOccurs="0" name="arg0" type="tns:WSGetItemPKsByCriteria"/&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;

  &lt;xs:complexType name="WSGetItemPKsByCriteria"&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element minOccurs="0" name="conceptName" type="xs:string"/&gt;
      &lt;xs:element minOccurs="0" name="contentKeywords" type="xs:string"/&gt;
      &lt;xs:element minOccurs="0" name="fromDate" type="xs:long"/&gt;
      &lt;xs:element minOccurs="0" name="keys" type="xs:string"/&gt;
      &lt;xs:element minOccurs="0" name="keysKeywords" type="xs:string"/&gt;
      &lt;xs:element name="maxItems" type="xs:int"/&gt;
      &lt;xs:element name="skip" type="xs:int"/&gt;
      &lt;xs:element minOccurs="0" name="toDate" type="xs:long"/&gt;
      &lt;xs:element minOccurs="0" name="wsDataClusterPK" type="tns:WSDataClusterPK"/&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;

  &lt;xs:complexType name="getItemPKsByCriteriaResponse"&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element minOccurs="0" name="return" type="tns:WSItemPKsByCriteriaResponse"/&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;

  &lt;xs:complexType name="WSItemPKsByCriteriaResponse"&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element maxOccurs="unbounded" minOccurs="0" name="results" nillable="true" type="tns:WSItemPKsByCriteriaResponseResults"/&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;

  &lt;xs:complexType name="WSItemPKsByCriteriaResponseResults"&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element name="date" type="xs:long"/&gt;
      &lt;xs:element minOccurs="0" name="taskId" type="xs:string"/&gt;
      &lt;xs:element minOccurs="0" name="wsItemPK" type="tns:WSItemPK"/&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;

  &lt;xs:complexType name="getDataClusterPKs"&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element minOccurs="0" name="arg0" type="tns:WSRegexDataClusterPKs"/&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;

  &lt;xs:complexType name="WSRegexDataClusterPKs"&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element minOccurs="0" name="regex" type="xs:string"/&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;

  &lt;xs:complexType name="getDataClusterPKsResponse"&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element minOccurs="0" name="return" type="tns:WSDataClusterPKArray"/&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;

  &lt;xs:complexType name="WSDataClusterPKArray"&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element maxOccurs="unbounded" minOccurs="0" name="wsDataClusterPKs" nillable="true" type="tns:WSDataClusterPK"/&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;

  &lt;xs:complexType name="getTransformer"&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element minOccurs="0" name="arg0" type="tns:WSGetTransformer"/&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;

  &lt;xs:complexType name="WSGetTransformer"&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element minOccurs="0" name="wsTransformerPK" type="tns:WSTransformerPK"/&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;

  &lt;xs:complexType name="getTransformerResponse"&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element minOccurs="0" name="return" type="tns:WSTransformer"/&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;

  &lt;xs:complexType name="getTransformerPluginV2Details"&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element minOccurs="0" name="arg0" type="tns:WSGetTransformerPluginV2Details"/&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;

  &lt;xs:complexType name="WSGetTransformerPluginV2Details"&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element minOccurs="0" name="jndiName" type="xs:string"/&gt;
      &lt;xs:element minOccurs="0" name="language" type="xs:string"/&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;

  &lt;xs:complexType name="getTransformerPluginV2DetailsResponse"&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element minOccurs="0" name="return" type="tns:WSTransformerPluginV2Details"/&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;

  &lt;xs:complexType name="WSTransformerPluginV2Details"&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element minOccurs="0" name="description" type="xs:string"/&gt;
      &lt;xs:element minOccurs="0" name="documentation" type="xs:string"/&gt;
      &lt;xs:element maxOccurs="unbounded" minOccurs="0" name="inputVariableDescriptors" nillable="true" type="tns:WSTransformerPluginV2VariableDescriptor"/&gt;
      &lt;xs:element maxOccurs="unbounded" minOccurs="0" name="outputVariableDescriptors" nillable="true" type="tns:WSTransformerPluginV2VariableDescriptor"/&gt;
      &lt;xs:element minOccurs="0" name="parametersSchema" type="xs:string"/&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;

  &lt;xs:complexType name="WSTransformerPluginV2VariableDescriptor"&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element maxOccurs="unbounded" minOccurs="0" name="contentTypesRegex" nillable="true" type="xs:string"/&gt;
      &lt;xs:element minOccurs="0" name="description" type="xs:string"/&gt;
      &lt;xs:element name="mandatory" type="xs:boolean"/&gt;
      &lt;xs:element maxOccurs="unbounded" minOccurs="0" name="possibleValuesRegex" nillable="true" type="xs:string"/&gt;
      &lt;xs:element minOccurs="0" name="variableName" type="xs:string"/&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;

  &lt;xs:complexType name="putServiceConfiguration"&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element minOccurs="0" name="arg0" type="tns:WSServicePutConfiguration"/&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;

  &lt;xs:complexType name="WSServicePutConfiguration"&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element minOccurs="0" name="configuration" type="xs:string"/&gt;
      &lt;xs:element minOccurs="0" name="jndiName" type="xs:string"/&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;

  &lt;xs:complexType name="putServiceConfigurationResponse"&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element minOccurs="0" name="return" type="tns:WSString"/&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;

  &lt;xs:complexType name="getItemPKsByFullCriteria"&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element minOccurs="0" name="arg0" type="tns:WSGetItemPKsByFullCriteria"/&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;

  &lt;xs:complexType name="WSGetItemPKsByFullCriteria"&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element name="useFTSearch" type="xs:boolean"/&gt;
      &lt;xs:element minOccurs="0" name="wsGetItemPKsByCriteria" type="tns:WSGetItemPKsByCriteria"/&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;

  &lt;xs:complexType name="getItemPKsByFullCriteriaResponse"&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element minOccurs="0" name="return" type="tns:WSItemPKsByCriteriaResponse"/&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;

  &lt;xs:complexType name="processFileUsingTransformer"&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element minOccurs="0" name="arg0" type="tns:WSProcessFileUsingTransformer"/&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;

  &lt;xs:complexType name="WSProcessFileUsingTransformer"&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element minOccurs="0" name="contentType" type="xs:string"/&gt;
      &lt;xs:element minOccurs="0" name="fileName" type="xs:string"/&gt;
      &lt;xs:element minOccurs="0" name="wsOutputDecisionTable" type="tns:WSOutputDecisionTable"/&gt;
      &lt;xs:element minOccurs="0" name="wsTransformerPK" type="tns:WSTransformerPK"/&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;

  &lt;xs:complexType name="processFileUsingTransformerResponse"&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element minOccurs="0" name="return" type="tns:WSPipeline"/&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;

  &lt;xs:complexType name="getFullPathValues"&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element minOccurs="0" name="arg0" type="tns:WSGetFullPathValues"/&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;

  &lt;xs:complexType name="WSGetFullPathValues"&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element minOccurs="0" name="direction" type="xs:string"/&gt;
      &lt;xs:element minOccurs="0" name="fullPath" type="xs:string"/&gt;
      &lt;xs:element minOccurs="0" name="orderBy" type="xs:string"/&gt;
      &lt;xs:element name="spellThreshold" type="xs:int"/&gt;
      &lt;xs:element minOccurs="0" name="whereItem" type="tns:WSWhereItem"/&gt;
      &lt;xs:element minOccurs="0" name="wsDataClusterPK" type="tns:WSDataClusterPK"/&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;

  &lt;xs:complexType name="getFullPathValuesResponse"&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element minOccurs="0" name="return" type="tns:WSStringArray"/&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;

  &lt;xs:complexType name="findAllDroppedItemsPKs"&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element minOccurs="0" name="arg0" type="tns:WSFindAllDroppedItemsPKs"/&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;

  &lt;xs:complexType name="WSFindAllDroppedItemsPKs"&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element minOccurs="0" name="regex" type="xs:string"/&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;

  &lt;xs:complexType name="findAllDroppedItemsPKsResponse"&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element minOccurs="0" name="return" type="tns:WSDroppedItemPKArray"/&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;

  &lt;xs:complexType name="WSDroppedItemPKArray"&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element maxOccurs="unbounded" minOccurs="0" name="wsDroppedItemPK" nillable="true" type="tns:WSDroppedItemPK"/&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;

  &lt;xs:complexType name="getMenuPKs"&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element minOccurs="0" name="arg0" type="tns:WSGetMenuPKs"/&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;

  &lt;xs:complexType name="WSGetMenuPKs"&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element minOccurs="0" name="regex" type="xs:string"/&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;

  &lt;xs:complexType name="getMenuPKsResponse"&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element minOccurs="0" name="return" type="tns:WSMenuPKArray"/&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;

  &lt;xs:complexType name="WSMenuPKArray"&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element maxOccurs="unbounded" minOccurs="0" name="wsMenuPK" nillable="true" type="tns:WSMenuPK"/&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;

  &lt;xs:complexType name="routeItemV2"&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element minOccurs="0" name="arg0" type="tns:WSRouteItemV2"/&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;

  &lt;xs:complexType name="WSRouteItemV2"&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element minOccurs="0" name="wsItemPK" type="tns:WSItemPK"/&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;

  &lt;xs:complexType name="routeItemV2Response"&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element minOccurs="0" name="return" type="tns:WSRoutingRulePKArray"/&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;

  &lt;xs:complexType name="ping"&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element minOccurs="0" name="arg0" type="tns:WSPing"/&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;

  &lt;xs:complexType name="WSPing"&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element minOccurs="0" name="echo" type="xs:string"/&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;

  &lt;xs:complexType name="pingResponse"&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element minOccurs="0" name="return" type="tns:WSString"/&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;

  &lt;xs:complexType name="getRoutingOrderV2PKsByCriteria"&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element minOccurs="0" name="arg0" type="tns:WSGetRoutingOrderV2PKsByCriteria"/&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;

  &lt;xs:complexType name="WSGetRoutingOrderV2PKsByCriteria"&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element minOccurs="0" name="wsSearchCriteria" type="tns:WSRoutingOrderV2SearchCriteria"/&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;

  &lt;xs:complexType name="getRoutingOrderV2PKsByCriteriaResponse"&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element minOccurs="0" name="return" type="tns:WSRoutingOrderV2PKArray"/&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;

  &lt;xs:complexType name="WSRoutingOrderV2PKArray"&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element maxOccurs="unbounded" minOccurs="0" name="wsRoutingOrder" nillable="true" type="tns:WSRoutingOrderV2PK"/&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;

  &lt;xs:complexType name="deleteTransformerV2"&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element minOccurs="0" name="arg0" type="tns:WSDeleteTransformerV2"/&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;

  &lt;xs:complexType name="WSDeleteTransformerV2"&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element minOccurs="0" name="wsTransformerV2PK" type="tns:WSTransformerV2PK"/&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;

  &lt;xs:complexType name="deleteTransformerV2Response"&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element minOccurs="0" name="return" type="tns:WSTransformerV2PK"/&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;

  &lt;xs:complexType name="putDataModel"&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element minOccurs="0" name="arg0" type="tns:WSPutDataModel"/&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;

  &lt;xs:complexType name="WSPutDataModel"&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element minOccurs="0" name="wsDataModel" type="tns:WSDataModel"/&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;

  &lt;xs:complexType name="putDataModelResponse"&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element minOccurs="0" name="return" type="tns:WSDataModelPK"/&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;

  &lt;xs:complexType name="getMDMCategory"&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element minOccurs="0" name="arg0" type="tns:WSCategoryData"/&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;

  &lt;xs:complexType name="WSCategoryData"&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element minOccurs="0" name="categorySchema" type="xs:string"/&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;

  &lt;xs:complexType name="getMDMCategoryResponse"&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element minOccurs="0" name="return" type="tns:WSCategoryData"/&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;

  &lt;xs:complexType name="checkServiceConfiguration"&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element minOccurs="0" name="arg0" type="tns:WSCheckServiceConfigRequest"/&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;

  &lt;xs:complexType name="WSCheckServiceConfigRequest"&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element minOccurs="0" name="conf" type="xs:string"/&gt;
      &lt;xs:element minOccurs="0" name="jndiName" type="xs:string"/&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;

  &lt;xs:complexType name="checkServiceConfigurationResponse"&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element minOccurs="0" name="return" type="tns:WSCheckServiceConfigResponse"/&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;

  &lt;xs:complexType name="WSCheckServiceConfigResponse"&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element minOccurs="0" name="checkResult" type="xs:boolean"/&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;

  &lt;xs:complexType name="getTransformerV2PKs"&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element minOccurs="0" name="arg0" type="tns:WSGetTransformerV2PKs"/&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;

  &lt;xs:complexType name="WSGetTransformerV2PKs"&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element minOccurs="0" name="regex" type="xs:string"/&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;

  &lt;xs:complexType name="getTransformerV2PKsResponse"&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element minOccurs="0" name="return" type="tns:WSTransformerV2PKArray"/&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;

  &lt;xs:complexType name="WSTransformerV2PKArray"&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element maxOccurs="unbounded" minOccurs="0" name="wsTransformerV2PK" nillable="true" type="tns:WSTransformerV2PK"/&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;

  &lt;xs:complexType name="putTransformerPluginV2Configuration"&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element minOccurs="0" name="arg0" type="tns:WSTransformerPluginV2PutConfiguration"/&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;

  &lt;xs:complexType name="WSTransformerPluginV2PutConfiguration"&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element minOccurs="0" name="configuration" type="xs:string"/&gt;
      &lt;xs:element minOccurs="0" name="jndiName" type="xs:string"/&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;

  &lt;xs:complexType name="putTransformerPluginV2ConfigurationResponse"&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element minOccurs="0" name="return" type="tns:WSString"/&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;

  &lt;xs:complexType name="getRole"&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element minOccurs="0" name="arg0" type="tns:WSGetRole"/&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;

  &lt;xs:complexType name="WSGetRole"&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element minOccurs="0" name="wsRolePK" type="tns:WSRolePK"/&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;

  &lt;xs:complexType name="getRoleResponse"&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element minOccurs="0" name="return" type="tns:WSRole"/&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;

  &lt;xs:complexType name="WSRole"&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element minOccurs="0" name="description" type="xs:string"/&gt;
      &lt;xs:element minOccurs="0" name="name" type="xs:string"/&gt;
      &lt;xs:element maxOccurs="unbounded" minOccurs="0" name="specification" nillable="true" type="tns:WSRoleSpecification"/&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;

  &lt;xs:complexType name="WSRoleSpecification"&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element name="admin" type="xs:boolean"/&gt;
      &lt;xs:element maxOccurs="unbounded" minOccurs="0" name="instance" nillable="true" type="tns:WSRoleSpecificationInstance"/&gt;
      &lt;xs:element minOccurs="0" name="objectType" type="xs:string"/&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;

  &lt;xs:complexType name="WSRoleSpecificationInstance"&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element minOccurs="0" name="instanceName" type="xs:string"/&gt;
      &lt;xs:element maxOccurs="unbounded" minOccurs="0" name="parameter" nillable="true" type="xs:string"/&gt;
      &lt;xs:element name="writable" type="xs:boolean"/&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;

  &lt;xs:complexType name="deleteView"&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element minOccurs="0" name="arg0" type="tns:WSDeleteView"/&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;

  &lt;xs:complexType name="WSDeleteView"&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element minOccurs="0" name="wsViewPK" type="tns:WSViewPK"/&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;

  &lt;xs:complexType name="deleteViewResponse"&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element minOccurs="0" name="return" type="tns:WSViewPK"/&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;

  &lt;xs:complexType name="deleteDataModel"&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element minOccurs="0" name="arg0" type="tns:WSDeleteDataModel"/&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;

  &lt;xs:complexType name="WSDeleteDataModel"&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element minOccurs="0" name="wsDataModelPK" type="tns:WSDataModelPK"/&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;

  &lt;xs:complexType name="deleteDataModelResponse"&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element minOccurs="0" name="return" type="tns:WSDataModelPK"/&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;

  &lt;xs:complexType name="putRole"&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element minOccurs="0" name="arg0" type="tns:WSPutRole"/&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;

  &lt;xs:complexType name="WSPutRole"&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element minOccurs="0" name="wsRole" type="tns:WSRole"/&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;

  &lt;xs:complexType name="putRoleResponse"&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element minOccurs="0" name="return" type="tns:WSRolePK"/&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;

  &lt;xs:complexType name="getRoutingOrderV2ByCriteriaWithPaging"&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element minOccurs="0" name="arg0" type="tns:WSGetRoutingOrderV2ByCriteriaWithPaging"/&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;

  &lt;xs:complexType name="WSGetRoutingOrderV2ByCriteriaWithPaging"&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element minOccurs="0" name="wsSearchCriteriaWithPaging" type="tns:WSRoutingOrderV2SearchCriteriaWithPaging"/&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;

  &lt;xs:complexType name="WSRoutingOrderV2SearchCriteriaWithPaging"&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element minOccurs="0" name="anyFieldContains" type="xs:string"/&gt;
      &lt;xs:element minOccurs="0" name="itemPKConceptContains" type="xs:string"/&gt;
      &lt;xs:element minOccurs="0" name="itemPKIDFieldsContain" type="xs:string"/&gt;
      &lt;xs:element name="maxItems" type="xs:int"/&gt;
      &lt;xs:element minOccurs="0" name="messageContain" type="xs:string"/&gt;
      &lt;xs:element minOccurs="0" name="nameContains" type="xs:string"/&gt;
      &lt;xs:element minOccurs="0" name="serviceJNDIContains" type="xs:string"/&gt;
      &lt;xs:element minOccurs="0" name="serviceParametersContain" type="xs:string"/&gt;
      &lt;xs:element name="skip" type="xs:int"/&gt;
      &lt;xs:element minOccurs="0" name="status" type="tns:WSRoutingOrderV2Status"/&gt;
      &lt;xs:element name="timeCreatedMax" type="xs:long"/&gt;
      &lt;xs:element name="timeCreatedMin" type="xs:long"/&gt;
      &lt;xs:element name="timeLastRunCompletedMax" type="xs:long"/&gt;
      &lt;xs:element name="timeLastRunCompletedMin" type="xs:long"/&gt;
      &lt;xs:element name="timeLastRunStartedMax" type="xs:long"/&gt;
      &lt;xs:element name="timeLastRunStartedMin" type="xs:long"/&gt;
      &lt;xs:element name="timeScheduledMax" type="xs:long"/&gt;
      &lt;xs:element name="timeScheduledMin" type="xs:long"/&gt;
      &lt;xs:element minOccurs="0" name="totalCountOnFirstResult" type="xs:boolean"/&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;

  &lt;xs:complexType name="getRoutingOrderV2ByCriteriaWithPagingResponse"&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element minOccurs="0" name="return" type="tns:WSRoutingOrderV2Array"/&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;

  &lt;xs:complexType name="getDataModelPKs"&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element minOccurs="0" name="arg0" type="tns:WSRegexDataModelPKs"/&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;

  &lt;xs:complexType name="WSRegexDataModelPKs"&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element minOccurs="0" name="regex" type="xs:string"/&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;

  &lt;xs:complexType name="getDataModelPKsResponse"&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element minOccurs="0" name="return" type="tns:WSDataModelPKArray"/&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;

  &lt;xs:complexType name="WSDataModelPKArray"&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element maxOccurs="unbounded" minOccurs="0" name="wsDataModelPKs" nillable="true" type="tns:WSDataModelPK"/&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;

  &lt;xs:complexType name="count"&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element minOccurs="0" name="arg0" type="tns:WSCount"/&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;

  &lt;xs:complexType name="WSCount"&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element minOccurs="0" name="countPath" type="xs:string"/&gt;
      &lt;xs:element name="spellTreshold" type="xs:int"/&gt;
      &lt;xs:element minOccurs="0" name="whereItem" type="tns:WSWhereItem"/&gt;
      &lt;xs:element minOccurs="0" name="wsDataClusterPK" type="tns:WSDataClusterPK"/&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;

  &lt;xs:complexType name="countResponse"&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element minOccurs="0" name="return" type="tns:WSString"/&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;

  &lt;xs:complexType name="existsDataCluster"&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element minOccurs="0" name="arg0" type="tns:WSExistsDataCluster"/&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;

  &lt;xs:complexType name="WSExistsDataCluster"&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element minOccurs="0" name="wsDataClusterPK" type="tns:WSDataClusterPK"/&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;

  &lt;xs:complexType name="existsDataClusterResponse"&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element minOccurs="0" name="return" type="tns:WSBoolean"/&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;

  &lt;xs:complexType name="recoverDroppedItem"&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element minOccurs="0" name="arg0" type="tns:WSRecoverDroppedItem"/&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;

  &lt;xs:complexType name="WSRecoverDroppedItem"&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element minOccurs="0" name="wsDroppedItemPK" type="tns:WSDroppedItemPK"/&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;

  &lt;xs:complexType name="recoverDroppedItemResponse"&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element minOccurs="0" name="return" type="tns:WSItemPK"/&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;

  &lt;xs:complexType name="loadDroppedItem"&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element minOccurs="0" name="arg0" type="tns:WSLoadDroppedItem"/&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;

  &lt;xs:complexType name="WSLoadDroppedItem"&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element minOccurs="0" name="wsDroppedItemPK" type="tns:WSDroppedItemPK"/&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;

  &lt;xs:complexType name="loadDroppedItemResponse"&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element minOccurs="0" name="return" type="tns:WSDroppedItem"/&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;

  &lt;xs:complexType name="WSDroppedItem"&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element minOccurs="0" name="conceptName" type="xs:string"/&gt;
      &lt;xs:element maxOccurs="unbounded" minOccurs="0" name="ids" nillable="true" type="xs:string"/&gt;
      &lt;xs:element minOccurs="0" name="insertionTime" type="xs:long"/&gt;
      &lt;xs:element minOccurs="0" name="insertionUserName" type="xs:string"/&gt;
      &lt;xs:element minOccurs="0" name="partPath" type="xs:string"/&gt;
      &lt;xs:element minOccurs="0" name="projection" type="xs:string"/&gt;
      &lt;xs:element minOccurs="0" name="uniqueId" type="xs:string"/&gt;
      &lt;xs:element minOccurs="0" name="wsDataClusterPK" type="tns:WSDataClusterPK"/&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;

  &lt;xs:complexType name="deleteRoutingRule"&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element minOccurs="0" name="arg0" type="tns:WSDeleteRoutingRule"/&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;

  &lt;xs:complexType name="WSDeleteRoutingRule"&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element minOccurs="0" name="wsRoutingRulePK" type="tns:WSRoutingRulePK"/&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;

  &lt;xs:complexType name="deleteRoutingRuleResponse"&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element minOccurs="0" name="return" type="tns:WSRoutingRulePK"/&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;

  &lt;xs:complexType name="getServiceConfiguration"&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element minOccurs="0" name="arg0" type="tns:WSServiceGetConfiguration"/&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;

  &lt;xs:complexType name="WSServiceGetConfiguration"&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element minOccurs="0" name="jndiName" type="xs:string"/&gt;
      &lt;xs:element minOccurs="0" name="optionalParameter" type="xs:string"/&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;

  &lt;xs:complexType name="getServiceConfigurationResponse"&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element minOccurs="0" name="return" type="tns:WSString"/&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;

  &lt;xs:complexType name="existsDBDataCluster"&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element minOccurs="0" name="arg0" type="tns:WSExistsDBDataCluster"/&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;

  &lt;xs:complexType name="WSExistsDBDataCluster"&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element minOccurs="0" name="name" type="xs:string"/&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;

  &lt;xs:complexType name="existsDBDataClusterResponse"&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element minOccurs="0" name="return" type="tns:WSBoolean"/&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;

  &lt;xs:complexType name="getTransformerPluginV2SList"&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element minOccurs="0" name="arg0" type="tns:WSGetTransformerPluginV2SList"/&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;

  &lt;xs:complexType name="WSGetTransformerPluginV2SList"&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element minOccurs="0" name="language" type="xs:string"/&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;

  &lt;xs:complexType name="getTransformerPluginV2SListResponse"&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element minOccurs="0" name="return" type="tns:WSTransformerPluginV2SList"/&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;

  &lt;xs:complexType name="WSTransformerPluginV2SList"&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element maxOccurs="unbounded" minOccurs="0" name="item" nillable="true" type="tns:WSTransformerPluginV2SListItem"/&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;

  &lt;xs:complexType name="WSTransformerPluginV2SListItem"&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element minOccurs="0" name="description" type="xs:string"/&gt;
      &lt;xs:element minOccurs="0" name="jndiName" type="xs:string"/&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;

  &lt;xs:complexType name="getRolePKs"&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element minOccurs="0" name="arg0" type="tns:WSGetRolePKs"/&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;

  &lt;xs:complexType name="WSGetRolePKs"&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element minOccurs="0" name="regex" type="xs:string"/&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;

  &lt;xs:complexType name="getRolePKsResponse"&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element minOccurs="0" name="return" type="tns:WSRolePKArray"/&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;

  &lt;xs:complexType name="WSRolePKArray"&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element maxOccurs="unbounded" minOccurs="0" name="wsRolePK" nillable="true" type="tns:WSRolePK"/&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;

  &lt;xs:complexType name="existsRoutingRule"&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element minOccurs="0" name="arg0" type="tns:WSExistsRoutingRule"/&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;

  &lt;xs:complexType name="WSExistsRoutingRule"&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element minOccurs="0" name="wsRoutingRulePK" type="tns:WSRoutingRulePK"/&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;

  &lt;xs:complexType name="existsRoutingRuleResponse"&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element minOccurs="0" name="return" type="tns:WSBoolean"/&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;

  &lt;xs:complexType name="getMDMConfiguration"&gt;
    &lt;xs:sequence/&gt;
  &lt;/xs:complexType&gt;

  &lt;xs:complexType name="getMDMConfigurationResponse"&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element minOccurs="0" name="return" type="tns:WSMDMConfig"/&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;

  &lt;xs:complexType name="WSMDMConfig"&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element minOccurs="0" name="isupurl" type="xs:string"/&gt;
      &lt;xs:element minOccurs="0" name="password" type="xs:string"/&gt;
      &lt;xs:element minOccurs="0" name="serverName" type="xs:string"/&gt;
      &lt;xs:element minOccurs="0" name="serverPort" type="xs:string"/&gt;
      &lt;xs:element minOccurs="0" name="userName" type="xs:string"/&gt;
      &lt;xs:element minOccurs="0" name="xdbDriver" type="xs:string"/&gt;
      &lt;xs:element minOccurs="0" name="xdbID" type="xs:string"/&gt;
      &lt;xs:element minOccurs="0" name="xdbUrl" type="xs:string"/&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;

  &lt;xs:complexType name="deleteDataCluster"&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element minOccurs="0" name="arg0" type="tns:WSDeleteDataCluster"/&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;

  &lt;xs:complexType name="WSDeleteDataCluster"&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element minOccurs="0" name="wsDataClusterPK" type="tns:WSDataClusterPK"/&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;

  &lt;xs:complexType name="deleteDataClusterResponse"&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element minOccurs="0" name="return" type="tns:WSDataClusterPK"/&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;

  &lt;xs:complexType name="executeRoutingOrderV2Asynchronously"&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element minOccurs="0" name="arg0" type="tns:WSExecuteRoutingOrderV2Asynchronously"/&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;

  &lt;xs:complexType name="WSExecuteRoutingOrderV2Asynchronously"&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element minOccurs="0" name="routingOrderV2PK" type="tns:WSRoutingOrderV2PK"/&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;

  &lt;xs:complexType name="executeRoutingOrderV2AsynchronouslyResponse"&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element minOccurs="0" name="return" type="tns:WSRoutingOrderV2PK"/&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;

  &lt;xs:complexType name="existsDataModel"&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element minOccurs="0" name="arg0" type="tns:WSExistsDataModel"/&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;

  &lt;xs:complexType name="WSExistsDataModel"&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element minOccurs="0" name="wsDataModelPK" type="tns:WSDataModelPK"/&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;

  &lt;xs:complexType name="existsDataModelResponse"&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element minOccurs="0" name="return" type="tns:WSBoolean"/&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;

  &lt;xs:complexType name="putMenu"&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element minOccurs="0" name="arg0" type="tns:WSPutMenu"/&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;

  &lt;xs:complexType name="WSPutMenu"&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element minOccurs="0" name="wsMenu" type="tns:WSMenu"/&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;

  &lt;xs:complexType name="putMenuResponse"&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element minOccurs="0" name="return" type="tns:WSMenuPK"/&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;

  &lt;xs:complexType name="getItem"&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element minOccurs="0" name="arg0" type="tns:WSGetItem"/&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;

  &lt;xs:complexType name="WSGetItem"&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element minOccurs="0" name="wsItemPK" type="tns:WSItemPK"/&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;

  &lt;xs:complexType name="getItemResponse"&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element minOccurs="0" name="return" type="tns:WSItem"/&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;

  &lt;xs:complexType name="extractThroughTransformerV2"&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element minOccurs="0" name="arg0" type="tns:WSExtractThroughTransformerV2"/&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;

  &lt;xs:complexType name="WSExtractThroughTransformerV2"&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element minOccurs="0" name="wsItemPK" type="tns:WSItemPK"/&gt;
      &lt;xs:element minOccurs="0" name="wsTransformerV2PK" type="tns:WSTransformerV2PK"/&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;

  &lt;xs:complexType name="extractThroughTransformerV2Response"&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element minOccurs="0" name="return" type="tns:WSTransformerContext"/&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;

  &lt;xs:complexType name="checkSchema"&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element minOccurs="0" name="arg0" type="tns:WSCheckSchema"/&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;

  &lt;xs:complexType name="WSCheckSchema"&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element minOccurs="0" name="schema" type="xs:string"/&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;

  &lt;xs:complexType name="checkSchemaResponse"&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element minOccurs="0" name="return" type="tns:WSString"/&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;

  &lt;xs:complexType name="xPathsSearch"&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element minOccurs="0" name="arg0" type="tns:WSXPathsSearch"/&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;

  &lt;xs:complexType name="WSXPathsSearch"&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element minOccurs="0" name="direction" type="xs:string"/&gt;
      &lt;xs:element name="maxItems" type="xs:int"/&gt;
      &lt;xs:element minOccurs="0" name="orderBy" type="xs:string"/&gt;
      &lt;xs:element minOccurs="0" name="pivotPath" type="xs:string"/&gt;
      &lt;xs:element minOccurs="0" name="returnCount" type="xs:boolean"/&gt;
      &lt;xs:element name="skip" type="xs:int"/&gt;
      &lt;xs:element name="spellTreshold" type="xs:int"/&gt;
      &lt;xs:element minOccurs="0" name="viewablePaths" type="tns:WSStringArray"/&gt;
      &lt;xs:element minOccurs="0" name="whereItem" type="tns:WSWhereItem"/&gt;
      &lt;xs:element minOccurs="0" name="wsDataClusterPK" type="tns:WSDataClusterPK"/&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;

  &lt;xs:complexType name="xPathsSearchResponse"&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element minOccurs="0" name="return" type="tns:WSStringArray"/&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;

  &lt;xs:complexType name="putBusinessConceptSchema"&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element minOccurs="0" name="arg0" type="tns:WSPutBusinessConceptSchema"/&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;

  &lt;xs:complexType name="WSPutBusinessConceptSchema"&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element minOccurs="0" name="businessConceptSchema" type="xs:string"/&gt;
      &lt;xs:element minOccurs="0" name="wsDataModelPK" type="tns:WSDataModelPK"/&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;

  &lt;xs:complexType name="putBusinessConceptSchemaResponse"&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element minOccurs="0" name="return" type="tns:WSString"/&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;

  &lt;xs:complexType name="partialPutItem"&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element minOccurs="0" name="arg0" type="tns:WSPartialPutItem"/&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;

  &lt;xs:complexType name="WSPartialPutItem"&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element minOccurs="0" name="datacluster" type="xs:string"/&gt;
      &lt;xs:element minOccurs="0" name="datamodel" type="xs:string"/&gt;
      &lt;xs:element minOccurs="0" name="delete" type="xs:boolean"/&gt;
      &lt;xs:element minOccurs="0" name="keyXPath" type="xs:string"/&gt;
      &lt;xs:element minOccurs="0" name="overwrite" type="xs:boolean"/&gt;
      &lt;xs:element minOccurs="0" name="pivot" type="xs:string"/&gt;
      &lt;xs:element name="report" type="xs:boolean"/&gt;
      &lt;xs:element minOccurs="0" name="source" type="xs:string"/&gt;
      &lt;xs:element minOccurs="0" name="startingPosition" type="xs:int"/&gt;
      &lt;xs:element minOccurs="0" name="xml" type="xs:string"/&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;

  &lt;xs:complexType name="partialPutItemResponse"&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element minOccurs="0" name="return" type="tns:WSItemPK"/&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;

  &lt;xs:complexType name="existsItem"&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element minOccurs="0" name="arg0" type="tns:WSExistsItem"/&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;

  &lt;xs:complexType name="WSExistsItem"&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element minOccurs="0" name="wsItemPK" type="tns:WSItemPK"/&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;

  &lt;xs:complexType name="existsItemResponse"&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element minOccurs="0" name="return" type="tns:WSBoolean"/&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;

  &lt;xs:complexType name="putDataCluster"&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element minOccurs="0" name="arg0" type="tns:WSPutDataCluster"/&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;

  &lt;xs:complexType name="WSPutDataCluster"&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element minOccurs="0" name="wsDataCluster" type="tns:WSDataCluster"/&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;

  &lt;xs:complexType name="putDataClusterResponse"&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element minOccurs="0" name="return" type="tns:WSDataClusterPK"/&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;

  &lt;xs:complexType name="routingEngineV2Action"&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element minOccurs="0" name="arg0" type="tns:WSRoutingEngineV2Action"/&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;

  &lt;xs:complexType name="WSRoutingEngineV2Action"&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element minOccurs="0" name="wsAction" type="tns:WSRoutingEngineV2ActionCode"/&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;

  &lt;xs:complexType name="routingEngineV2ActionResponse"&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element minOccurs="0" name="return" type="tns:WSRoutingEngineV2Status"/&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;

  &lt;xs:complexType name="extractUsingTransformer"&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element minOccurs="0" name="arg0" type="tns:WSExtractUsingTransformer"/&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;

  &lt;xs:complexType name="WSExtractUsingTransformer"&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element minOccurs="0" name="wsItemPK" type="tns:WSItemPK"/&gt;
      &lt;xs:element minOccurs="0" name="wsTransformerPK" type="tns:WSTransformerPK"/&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;

  &lt;xs:complexType name="extractUsingTransformerResponse"&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element minOccurs="0" name="return" type="tns:WSPipeline"/&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;

  &lt;xs:complexType name="getServicesList"&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element minOccurs="0" name="arg0" type="tns:WSGetServicesList"/&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;

  &lt;xs:complexType name="WSGetServicesList"&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element minOccurs="0" name="language" type="xs:string"/&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;

  &lt;xs:complexType name="getServicesListResponse"&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element minOccurs="0" name="return" type="tns:WSServicesList"/&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;

  &lt;xs:complexType name="WSServicesList"&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element maxOccurs="unbounded" minOccurs="0" name="item" nillable="true" type="tns:WSServicesListItem"/&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;

  &lt;xs:complexType name="WSServicesListItem"&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element minOccurs="0" name="jndiName" type="xs:string"/&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;

  &lt;xs:complexType name="getView"&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element minOccurs="0" name="arg0" type="tns:WSGetView"/&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;

  &lt;xs:complexType name="WSGetView"&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element minOccurs="0" name="wsViewPK" type="tns:WSViewPK"/&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;

  &lt;xs:complexType name="getViewResponse"&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element minOccurs="0" name="return" type="tns:WSView"/&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;

  &lt;xs:complexType name="putRoutingRule"&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element minOccurs="0" name="arg0" type="tns:WSPutRoutingRule"/&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;

  &lt;xs:complexType name="WSPutRoutingRule"&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element minOccurs="0" name="wsRoutingRule" type="tns:WSRoutingRule"/&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;

  &lt;xs:complexType name="putRoutingRuleResponse"&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element minOccurs="0" name="return" type="tns:WSRoutingRulePK"/&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;

  &lt;xs:complexType name="getItems"&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element minOccurs="0" name="arg0" type="tns:WSGetItems"/&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;

  &lt;xs:complexType name="WSGetItems"&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element minOccurs="0" name="conceptName" type="xs:string"/&gt;
      &lt;xs:element name="maxItems" type="xs:int"/&gt;
      &lt;xs:element name="skip" type="xs:int"/&gt;
      &lt;xs:element name="spellTreshold" type="xs:int"/&gt;
      &lt;xs:element minOccurs="0" name="totalCountOnFirstResult" type="xs:boolean"/&gt;
      &lt;xs:element minOccurs="0" name="whereItem" type="tns:WSWhereItem"/&gt;
      &lt;xs:element minOccurs="0" name="wsDataClusterPK" type="tns:WSDataClusterPK"/&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;

  &lt;xs:complexType name="getItemsResponse"&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element minOccurs="0" name="return" type="tns:WSStringArray"/&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;

  &lt;xs:complexType name="isPagingAccurate"&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element minOccurs="0" name="arg0" type="tns:WSInt"/&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;

  &lt;xs:complexType name="isPagingAccurateResponse"&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element minOccurs="0" name="return" type="tns:WSBoolean"/&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;

  &lt;xs:complexType name="getAutoIncrement"&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element minOccurs="0" name="arg0" type="tns:WSAutoIncrement"/&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;

  &lt;xs:complexType name="WSAutoIncrement"&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element minOccurs="0" name="autoincrement" type="xs:string"/&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;

  &lt;xs:complexType name="getAutoIncrementResponse"&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element minOccurs="0" name="return" type="tns:WSAutoIncrement"/&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;

  &lt;xs:complexType name="executeTransformerV2AsJob"&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element minOccurs="0" name="arg0" type="tns:WSExecuteTransformerV2AsJob"/&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;

  &lt;xs:complexType name="WSExecuteTransformerV2AsJob"&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element minOccurs="0" name="wsTransformerContext" type="tns:WSTransformerContext"/&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;

  &lt;xs:complexType name="executeTransformerV2AsJobResponse"&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element minOccurs="0" name="return" type="tns:WSBackgroundJobPK"/&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;

  &lt;xs:complexType name="putBackgroundJob"&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element minOccurs="0" name="arg0" type="tns:WSPutBackgroundJob"/&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;

  &lt;xs:complexType name="WSPutBackgroundJob"&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element minOccurs="0" name="wsBackgroundJob" type="tns:WSBackgroundJob"/&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;

  &lt;xs:complexType name="putBackgroundJobResponse"&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element minOccurs="0" name="return" type="tns:WSBackgroundJobPK"/&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;

  &lt;xs:complexType name="putTransformerV2"&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element minOccurs="0" name="arg0" type="tns:WSPutTransformerV2"/&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;

  &lt;xs:complexType name="WSPutTransformerV2"&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element minOccurs="0" name="wsTransformerV2" type="tns:WSTransformerV2"/&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;

  &lt;xs:complexType name="putTransformerV2Response"&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element minOccurs="0" name="return" type="tns:WSTransformerV2PK"/&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;

  &lt;xs:complexType name="extractUsingTransformerThruView"&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element minOccurs="0" name="arg0" type="tns:WSExtractUsingTransformerThruView"/&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;

  &lt;xs:complexType name="WSExtractUsingTransformerThruView"&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element minOccurs="0" name="direction" type="xs:string"/&gt;
      &lt;xs:element name="maxItems" type="xs:int"/&gt;
      &lt;xs:element minOccurs="0" name="orderBy" type="xs:string"/&gt;
      &lt;xs:element name="skip" type="xs:int"/&gt;
      &lt;xs:element name="spellTreshold" type="xs:int"/&gt;
      &lt;xs:element minOccurs="0" name="whereItem" type="tns:WSWhereItem"/&gt;
      &lt;xs:element minOccurs="0" name="wsDataClusterPK" type="tns:WSDataClusterPK"/&gt;
      &lt;xs:element minOccurs="0" name="wsTransformerPK" type="tns:WSTransformerPK"/&gt;
      &lt;xs:element minOccurs="0" name="wsViewPK" type="tns:WSViewPK"/&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;

  &lt;xs:complexType name="extractUsingTransformerThruViewResponse"&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element minOccurs="0" name="return" type="tns:WSPipeline"/&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;

  &lt;xs:complexType name="getBusinessConceptValue"&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element minOccurs="0" name="arg0" type="tns:WSGetBusinessConceptValue"/&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;

  &lt;xs:complexType name="WSGetBusinessConceptValue"&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element minOccurs="0" name="wsBusinessConceptPK" type="tns:WSBusinessConceptPK"/&gt;
      &lt;xs:element minOccurs="0" name="wsDataClusterPK" type="tns:WSDataClusterPK"/&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;

  &lt;xs:complexType name="WSBusinessConceptPK"&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element minOccurs="0" name="conceptName" type="xs:string"/&gt;
      &lt;xs:element maxOccurs="unbounded" minOccurs="0" name="ids" nillable="true" type="xs:string"/&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;

  &lt;xs:complexType name="getBusinessConceptValueResponse"&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element minOccurs="0" name="return" type="tns:WSString"/&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;

  &lt;xs:simpleType name="BackgroundJobStatusType"&gt;
    &lt;xs:restriction base="xs:string"&gt;
      &lt;xs:enumeration value="SCHEDULED"/&gt;
      &lt;xs:enumeration value="RUNNING"/&gt;
      &lt;xs:enumeration value="COMPLETED"/&gt;
      &lt;xs:enumeration value="SUSPENDED"/&gt;
      &lt;xs:enumeration value="CANCEL_REQUESTED"/&gt;
      &lt;xs:enumeration value="STOPPED"/&gt;
    &lt;/xs:restriction&gt;
  &lt;/xs:simpleType&gt;

  &lt;xs:simpleType name="WSWhereOperator"&gt;
    &lt;xs:restriction base="xs:string"&gt;
      &lt;xs:enumeration value="JOIN"/&gt;
      &lt;xs:enumeration value="CONTAINS_TEXT_OF"/&gt;
      &lt;xs:enumeration value="CONTAINS"/&gt;
      &lt;xs:enumeration value="STARTSWITH"/&gt;
      &lt;xs:enumeration value="STRICTCONTAINS"/&gt;
      &lt;xs:enumeration value="EQUALS"/&gt;
      &lt;xs:enumeration value="NOT_EQUALS"/&gt;
      &lt;xs:enumeration value="GREATER_THAN"/&gt;
      &lt;xs:enumeration value="GREATER_THAN_OR_EQUAL"/&gt;
      &lt;xs:enumeration value="LOWER_THAN"/&gt;
      &lt;xs:enumeration value="LOWER_THAN_OR_EQUAL"/&gt;
      &lt;xs:enumeration value="NO_OPERATOR"/&gt;
      &lt;xs:enumeration value="FULLTEXTSEARCH"/&gt;
      &lt;xs:enumeration value="EMPTY_NULL"/&gt;
    &lt;/xs:restriction&gt;
  &lt;/xs:simpleType&gt;

  &lt;xs:simpleType name="WSStringPredicate"&gt;
    &lt;xs:restriction base="xs:string"&gt;
      &lt;xs:enumeration value="NONE"/&gt;
      &lt;xs:enumeration value="OR"/&gt;
      &lt;xs:enumeration value="AND"/&gt;
      &lt;xs:enumeration value="STRICTAND"/&gt;
      &lt;xs:enumeration value="EXACTLY"/&gt;
      &lt;xs:enumeration value="NOT"/&gt;
    &lt;/xs:restriction&gt;
  &lt;/xs:simpleType&gt;

  &lt;xs:simpleType name="WSRoutingOrderV2Status"&gt;
    &lt;xs:restriction base="xs:string"&gt;
      &lt;xs:enumeration value="ACTIVE"/&gt;
      &lt;xs:enumeration value="FAILED"/&gt;
      &lt;xs:enumeration value="COMPLETED"/&gt;
    &lt;/xs:restriction&gt;
  &lt;/xs:simpleType&gt;

  &lt;xs:simpleType name="fkIntegrityCheckResult"&gt;
    &lt;xs:restriction base="xs:string"&gt;
      &lt;xs:enumeration value="FORBIDDEN"/&gt;
      &lt;xs:enumeration value="FORBIDDEN_OVERRIDE_ALLOWED"/&gt;
      &lt;xs:enumeration value="ALLOWED"/&gt;
    &lt;/xs:restriction&gt;
  &lt;/xs:simpleType&gt;

  &lt;xs:simpleType name="WSComponent"&gt;
    &lt;xs:restriction base="xs:string"&gt;
      &lt;xs:enumeration value="DataManager"/&gt;
      &lt;xs:enumeration value="Service"/&gt;
      &lt;xs:enumeration value="Connector"/&gt;
    &lt;/xs:restriction&gt;
  &lt;/xs:simpleType&gt;

  &lt;xs:simpleType name="WSRoutingRuleOperator"&gt;
    &lt;xs:restriction base="xs:string"&gt;
      &lt;xs:enumeration value="CONTAINS"/&gt;
      &lt;xs:enumeration value="MATCHES"/&gt;
      &lt;xs:enumeration value="STARTSWITH"/&gt;
      &lt;xs:enumeration value="EQUALS"/&gt;
      &lt;xs:enumeration value="NOT_EQUALS"/&gt;
      &lt;xs:enumeration value="GREATER_THAN"/&gt;
      &lt;xs:enumeration value="GREATER_THAN_OR_EQUAL"/&gt;
      &lt;xs:enumeration value="LOWER_THAN"/&gt;
      &lt;xs:enumeration value="LOWER_THAN_OR_EQUAL"/&gt;
      &lt;xs:enumeration value="IS_NULL"/&gt;
      &lt;xs:enumeration value="IS_NOT_NULL"/&gt;
    &lt;/xs:restriction&gt;
  &lt;/xs:simpleType&gt;

  &lt;xs:simpleType name="WSLanguage"&gt;
    &lt;xs:restriction base="xs:string"&gt;
      &lt;xs:enumeration value="FR"/&gt;
      &lt;xs:enumeration value="EN"/&gt;
    &lt;/xs:restriction&gt;
  &lt;/xs:simpleType&gt;

  &lt;xs:simpleType name="WSServiceActionCode"&gt;
    &lt;xs:restriction base="xs:string"&gt;
      &lt;xs:enumeration value="START"/&gt;
      &lt;xs:enumeration value="STOP"/&gt;
      &lt;xs:enumeration value="STATUS"/&gt;
      &lt;xs:enumeration value="EXECUTE"/&gt;
    &lt;/xs:restriction&gt;
  &lt;/xs:simpleType&gt;

  &lt;xs:simpleType name="WSRoutingEngineV2ActionCode"&gt;
    &lt;xs:restriction base="xs:string"&gt;
      &lt;xs:enumeration value="START"/&gt;
      &lt;xs:enumeration value="STOP"/&gt;
      &lt;xs:enumeration value="SUSPEND"/&gt;
      &lt;xs:enumeration value="RESUME"/&gt;
      &lt;xs:enumeration value="STATUS"/&gt;
    &lt;/xs:restriction&gt;
  &lt;/xs:simpleType&gt;

  &lt;xs:simpleType name="WSRoutingEngineV2Status"&gt;
    &lt;xs:restriction base="xs:string"&gt;
      &lt;xs:enumeration value="DEAD"/&gt;
      &lt;xs:enumeration value="STOPPED"/&gt;
      &lt;xs:enumeration value="SUSPENDED"/&gt;
      &lt;xs:enumeration value="RUNNING"/&gt;
    &lt;/xs:restriction&gt;
  &lt;/xs:simpleType&gt;

&lt;/xs:schema&gt;</string></schemas><encoding>GBK</encoding><baseUri>http://127.0.0.1:8080/talendmdm/services/soap?wsdl</baseUri></schemas><rootElement><namespaceURI>http://www.talend.com/mdm</namespaceURI><localPart>putItemWithReport</localPart><prefix></prefix></rootElement></model><accessType>READ_WRITE</accessType><metaDataFieldPropertyManager><properties><org.mule.common.metadata.property.QNameMetaDataProperty><name><namespaceURI></namespaceURI><localPart>wsDataClusterPK</localPart><prefix></prefix></name></org.mule.common.metadata.property.QNameMetaDataProperty></properties></metaDataFieldPropertyManager></org.mule.common.metadata.DefaultMetaDataField><org.mule.common.metadata.DefaultMetaDataField><name>wsDataModelPK</name><model class="org.mule.common.metadata.DefaultXmlMetaDataModel"><dataType>XML</dataType><metaDataModelPropertiesManager><properties></properties></metaDataModelPropertiesManager><fields><org.mule.common.metadata.DefaultMetaDataField><name>pk</name><model class="org.mule.common.metadata.DefaultSimpleMetaDataModel"><dataType>STRING</dataType><metaDataModelPropertiesManager><properties></properties></metaDataModelPropertiesManager></model><accessType>READ_WRITE</accessType><metaDataFieldPropertyManager><properties><org.mule.common.metadata.property.QNameMetaDataProperty><name><namespaceURI></namespaceURI><localPart>pk</localPart><prefix></prefix></name></org.mule.common.metadata.property.QNameMetaDataProperty></properties></metaDataFieldPropertyManager></org.mule.common.metadata.DefaultMetaDataField></fields><schemas class="org.mule.common.metadata.StringBasedSchemaProvider" reference="../../../org.mule.common.metadata.DefaultMetaDataField[2]/model/schemas"></schemas><rootElement reference="../../../org.mule.common.metadata.DefaultMetaDataField[2]/model/rootElement"></rootElement></model><accessType>READ_WRITE</accessType><metaDataFieldPropertyManager><properties><org.mule.common.metadata.property.QNameMetaDataProperty><name><namespaceURI></namespaceURI><localPart>wsDataModelPK</localPart><prefix></prefix></name></org.mule.common.metadata.property.QNameMetaDataProperty></properties></metaDataFieldPropertyManager></org.mule.common.metadata.DefaultMetaDataField><org.mule.common.metadata.DefaultMetaDataField><name>xmlString</name><model class="org.mule.common.metadata.DefaultSimpleMetaDataModel"><dataType>STRING</dataType><metaDataModelPropertiesManager><properties></properties></metaDataModelPropertiesManager></model><accessType>READ_WRITE</accessType><metaDataFieldPropertyManager><properties><org.mule.common.metadata.property.QNameMetaDataProperty><name><namespaceURI></namespaceURI><localPart>xmlString</localPart><prefix></prefix></name></org.mule.common.metadata.property.QNameMetaDataProperty></properties></metaDataFieldPropertyManager></org.mule.common.metadata.DefaultMetaDataField></fields><schemas class="org.mule.common.metadata.StringBasedSchemaProvider" reference="../fields/org.mule.common.metadata.DefaultMetaDataField[2]/model/schemas"></schemas><rootElement reference="../fields/org.mule.common.metadata.DefaultMetaDataField[2]/model/rootElement"></rootElement></model><accessType>READ_WRITE</accessType><metaDataFieldPropertyManager><properties><org.mule.common.metadata.property.QNameMetaDataProperty><name><namespaceURI></namespaceURI><localPart>wsPutItem</localPart><prefix></prefix></name></org.mule.common.metadata.property.QNameMetaDataProperty></properties></metaDataFieldPropertyManager></org.mule.common.metadata.DefaultMetaDataField></fields><schemas class="org.mule.common.metadata.StringBasedSchemaProvider" reference="../fields/org.mule.common.metadata.DefaultMetaDataField[3]/model/fields/org.mule.common.metadata.DefaultMetaDataField[2]/model/schemas"></schemas><rootElement reference="../fields/org.mule.common.metadata.DefaultMetaDataField[3]/model/fields/org.mule.common.metadata.DefaultMetaDataField[2]/model/rootElement"></rootElement></model><accessType>READ_WRITE</accessType><metaDataFieldPropertyManager><properties><org.mule.common.metadata.property.QNameMetaDataProperty><name><namespaceURI></namespaceURI><localPart>arg0</localPart><prefix></prefix></name></org.mule.common.metadata.property.QNameMetaDataProperty></properties></metaDataFieldPropertyManager></org.mule.common.metadata.DefaultMetaDataField></fields><schemas class="org.mule.common.metadata.StringBasedSchemaProvider"><schemas reference="../../fields/org.mule.common.metadata.DefaultMetaDataField/model/fields/org.mule.common.metadata.DefaultMetaDataField[3]/model/fields/org.mule.common.metadata.DefaultMetaDataField[2]/model/schemas/schemas"></schemas><encoding reference="../../fields/org.mule.common.metadata.DefaultMetaDataField/model/fields/org.mule.common.metadata.DefaultMetaDataField[3]/model/fields/org.mule.common.metadata.DefaultMetaDataField[2]/model/schemas/encoding"></encoding><baseUri>http://127.0.0.1:8080/talendmdm/services/soap?wsdl</baseUri></schemas><rootElement reference="../fields/org.mule.common.metadata.DefaultMetaDataField/model/fields/org.mule.common.metadata.DefaultMetaDataField[3]/model/fields/org.mule.common.metadata.DefaultMetaDataField[2]/model/rootElement"></rootElement></payload><properties><entry><org.mule.common.metadata.MetaDataPropertyScope>RECORD</org.mule.common.metadata.MetaDataPropertyScope><org.mule.common.metadata.MetaDataProperties><fields></fields></org.mule.common.metadata.MetaDataProperties></entry><entry><org.mule.common.metadata.MetaDataPropertyScope>INBOUND</org.mule.common.metadata.MetaDataPropertyScope><org.mule.common.metadata.MetaDataProperties><fields></fields></org.mule.common.metadata.MetaDataProperties></entry><entry><org.mule.common.metadata.MetaDataPropertyScope>OUTBOUND</org.mule.common.metadata.MetaDataPropertyScope><org.mule.common.metadata.MetaDataProperties><fields></fields></org.mule.common.metadata.MetaDataProperties></entry><entry><org.mule.common.metadata.MetaDataPropertyScope>SESSION</org.mule.common.metadata.MetaDataPropertyScope><org.mule.common.metadata.MetaDataProperties><fields></fields></org.mule.common.metadata.MetaDataProperties></entry><entry><org.mule.common.metadata.MetaDataPropertyScope>FLOW</org.mule.common.metadata.MetaDataPropertyScope><org.mule.common.metadata.MetaDataProperties><fields></fields></org.mule.common.metadata.MetaDataProperties></entry></properties></input><output class="org.mule.common.metadata.DefaultMetaData"><payload class="org.mule.common.metadata.DefaultXmlMetaDataModel"><dataType>XML</dataType><metaDataModelPropertiesManager><properties><org.mule.common.metadata.property.TextBasedExampleMetaDataModelProperty></org.mule.common.metadata.property.TextBasedExampleMetaDataModelProperty></properties></metaDataModelPropertiesManager><fields><org.mule.common.metadata.DefaultMetaDataField><name>return</name><model class="org.mule.common.metadata.DefaultXmlMetaDataModel"><dataType>XML</dataType><metaDataModelPropertiesManager><properties></properties></metaDataModelPropertiesManager><fields><org.mule.common.metadata.DefaultMetaDataField><name>conceptName</name><model class="org.mule.common.metadata.DefaultSimpleMetaDataModel"><dataType>STRING</dataType><metaDataModelPropertiesManager><properties></properties></metaDataModelPropertiesManager></model><accessType>READ_WRITE</accessType><metaDataFieldPropertyManager><properties><org.mule.common.metadata.property.QNameMetaDataProperty><name><namespaceURI></namespaceURI><localPart>conceptName</localPart><prefix></prefix></name></org.mule.common.metadata.property.QNameMetaDataProperty></properties></metaDataFieldPropertyManager></org.mule.common.metadata.DefaultMetaDataField><org.mule.common.metadata.DefaultMetaDataField><name>ids</name><model class="org.mule.common.metadata.DefaultListMetaDataModel"><dataType>LIST</dataType><metaDataModelPropertiesManager><properties></properties></metaDataModelPropertiesManager><model class="org.mule.common.metadata.DefaultSimpleMetaDataModel"><dataType>STRING</dataType><metaDataModelPropertiesManager><properties></properties></metaDataModelPropertiesManager></model><isArray>false</isArray></model><accessType>READ_WRITE</accessType><metaDataFieldPropertyManager><properties><org.mule.common.metadata.property.QNameMetaDataProperty><name><namespaceURI></namespaceURI><localPart>ids</localPart><prefix></prefix></name></org.mule.common.metadata.property.QNameMetaDataProperty></properties></metaDataFieldPropertyManager></org.mule.common.metadata.DefaultMetaDataField><org.mule.common.metadata.DefaultMetaDataField><name>wsDataClusterPK</name><model class="org.mule.common.metadata.DefaultXmlMetaDataModel"><dataType>XML</dataType><metaDataModelPropertiesManager><properties></properties></metaDataModelPropertiesManager><fields><org.mule.common.metadata.DefaultMetaDataField><name>pk</name><model class="org.mule.common.metadata.DefaultSimpleMetaDataModel"><dataType>STRING</dataType><metaDataModelPropertiesManager><properties></properties></metaDataModelPropertiesManager></model><accessType>READ_WRITE</accessType><metaDataFieldPropertyManager><properties><org.mule.common.metadata.property.QNameMetaDataProperty><name><namespaceURI></namespaceURI><localPart>pk</localPart><prefix></prefix></name></org.mule.common.metadata.property.QNameMetaDataProperty></properties></metaDataFieldPropertyManager></org.mule.common.metadata.DefaultMetaDataField></fields><schemas class="org.mule.common.metadata.StringBasedSchemaProvider"><schemas><string>&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;xs:schema xmlns:xs="http://www.w3.org/2001/XMLSchema" xmlns:ns1="http://schemas.xmlsoap.org/soap/http" xmlns:soap="http://schemas.xmlsoap.org/wsdl/soap/" xmlns:tns="http://www.talend.com/mdm" xmlns:wsdl="http://schemas.xmlsoap.org/wsdl/" xmlns:xsd="http://www.w3.org/2001/XMLSchema" elementFormDefault="unqualified" targetNamespace="http://www.talend.com/mdm" version="1.0"&gt;

  &lt;xs:element name="checkFKIntegrity" type="tns:checkFKIntegrity"/&gt;

  &lt;xs:element name="checkFKIntegrityResponse" type="tns:checkFKIntegrityResponse"/&gt;

  &lt;xs:element name="checkSchema" type="tns:checkSchema"/&gt;

  &lt;xs:element name="checkSchemaResponse" type="tns:checkSchemaResponse"/&gt;

  &lt;xs:element name="checkServiceConfiguration" type="tns:checkServiceConfiguration"/&gt;

  &lt;xs:element name="checkServiceConfigurationResponse" type="tns:checkServiceConfigurationResponse"/&gt;

  &lt;xs:element name="count" type="tns:count"/&gt;

  &lt;xs:element name="countItemsByCustomFKFilters" type="tns:countItemsByCustomFKFilters"/&gt;

  &lt;xs:element name="countItemsByCustomFKFiltersResponse" type="tns:countItemsByCustomFKFiltersResponse"/&gt;

  &lt;xs:element name="countResponse" type="tns:countResponse"/&gt;

  &lt;xs:element name="deleteBusinessConcept" type="tns:deleteBusinessConcept"/&gt;

  &lt;xs:element name="deleteBusinessConceptResponse" type="tns:deleteBusinessConceptResponse"/&gt;

  &lt;xs:element name="deleteDataCluster" type="tns:deleteDataCluster"/&gt;

  &lt;xs:element name="deleteDataClusterResponse" type="tns:deleteDataClusterResponse"/&gt;

  &lt;xs:element name="deleteDataModel" type="tns:deleteDataModel"/&gt;

  &lt;xs:element name="deleteDataModelResponse" type="tns:deleteDataModelResponse"/&gt;

  &lt;xs:element name="deleteItem" type="tns:deleteItem"/&gt;

  &lt;xs:element name="deleteItemResponse" type="tns:deleteItemResponse"/&gt;

  &lt;xs:element name="deleteItemWithReport" type="tns:deleteItemWithReport"/&gt;

  &lt;xs:element name="deleteItemWithReportResponse" type="tns:deleteItemWithReportResponse"/&gt;

  &lt;xs:element name="deleteItems" type="tns:deleteItems"/&gt;

  &lt;xs:element name="deleteItemsResponse" type="tns:deleteItemsResponse"/&gt;

  &lt;xs:element name="deleteMenu" type="tns:deleteMenu"/&gt;

  &lt;xs:element name="deleteMenuResponse" type="tns:deleteMenuResponse"/&gt;

  &lt;xs:element name="deleteRole" type="tns:deleteRole"/&gt;

  &lt;xs:element name="deleteRoleResponse" type="tns:deleteRoleResponse"/&gt;

  &lt;xs:element name="deleteRoutingOrderV2" type="tns:deleteRoutingOrderV2"/&gt;

  &lt;xs:element name="deleteRoutingOrderV2Response" type="tns:deleteRoutingOrderV2Response"/&gt;

  &lt;xs:element name="deleteRoutingRule" type="tns:deleteRoutingRule"/&gt;

  &lt;xs:element name="deleteRoutingRuleResponse" type="tns:deleteRoutingRuleResponse"/&gt;

  &lt;xs:element name="deleteStoredProcedure" type="tns:deleteStoredProcedure"/&gt;

  &lt;xs:element name="deleteStoredProcedureResponse" type="tns:deleteStoredProcedureResponse"/&gt;

  &lt;xs:element name="deleteTransformerV2" type="tns:deleteTransformerV2"/&gt;

  &lt;xs:element name="deleteTransformerV2Response" type="tns:deleteTransformerV2Response"/&gt;

  &lt;xs:element name="deleteView" type="tns:deleteView"/&gt;

  &lt;xs:element name="deleteViewResponse" type="tns:deleteViewResponse"/&gt;

  &lt;xs:element name="dropItem" type="tns:dropItem"/&gt;

  &lt;xs:element name="dropItemResponse" type="tns:dropItemResponse"/&gt;

  &lt;xs:element name="executeRoutingOrderV2Asynchronously" type="tns:executeRoutingOrderV2Asynchronously"/&gt;

  &lt;xs:element name="executeRoutingOrderV2AsynchronouslyResponse" type="tns:executeRoutingOrderV2AsynchronouslyResponse"/&gt;

  &lt;xs:element name="executeRoutingOrderV2Synchronously" type="tns:executeRoutingOrderV2Synchronously"/&gt;

  &lt;xs:element name="executeRoutingOrderV2SynchronouslyResponse" type="tns:executeRoutingOrderV2SynchronouslyResponse"/&gt;

  &lt;xs:element name="executeStoredProcedure" type="tns:executeStoredProcedure"/&gt;

  &lt;xs:element name="executeStoredProcedureResponse" type="tns:executeStoredProcedureResponse"/&gt;

  &lt;xs:element name="executeTransformerV2" type="tns:executeTransformerV2"/&gt;

  &lt;xs:element name="executeTransformerV2AsJob" type="tns:executeTransformerV2AsJob"/&gt;

  &lt;xs:element name="executeTransformerV2AsJobResponse" type="tns:executeTransformerV2AsJobResponse"/&gt;

  &lt;xs:element name="executeTransformerV2Response" type="tns:executeTransformerV2Response"/&gt;

  &lt;xs:element name="existsDBDataCluster" type="tns:existsDBDataCluster"/&gt;

  &lt;xs:element name="existsDBDataClusterResponse" type="tns:existsDBDataClusterResponse"/&gt;

  &lt;xs:element name="existsDataCluster" type="tns:existsDataCluster"/&gt;

  &lt;xs:element name="existsDataClusterResponse" type="tns:existsDataClusterResponse"/&gt;

  &lt;xs:element name="existsDataModel" type="tns:existsDataModel"/&gt;

  &lt;xs:element name="existsDataModelResponse" type="tns:existsDataModelResponse"/&gt;

  &lt;xs:element name="existsItem" type="tns:existsItem"/&gt;

  &lt;xs:element name="existsItemResponse" type="tns:existsItemResponse"/&gt;

  &lt;xs:element name="existsMenu" type="tns:existsMenu"/&gt;

  &lt;xs:element name="existsMenuResponse" type="tns:existsMenuResponse"/&gt;

  &lt;xs:element name="existsRole" type="tns:existsRole"/&gt;

  &lt;xs:element name="existsRoleResponse" type="tns:existsRoleResponse"/&gt;

  &lt;xs:element name="existsRoutingRule" type="tns:existsRoutingRule"/&gt;

  &lt;xs:element name="existsRoutingRuleResponse" type="tns:existsRoutingRuleResponse"/&gt;

  &lt;xs:element name="existsStoredProcedure" type="tns:existsStoredProcedure"/&gt;

  &lt;xs:element name="existsStoredProcedureResponse" type="tns:existsStoredProcedureResponse"/&gt;

  &lt;xs:element name="existsTransformer" type="tns:existsTransformer"/&gt;

  &lt;xs:element name="existsTransformerPluginV2" type="tns:existsTransformerPluginV2"/&gt;

  &lt;xs:element name="existsTransformerPluginV2Response" type="tns:existsTransformerPluginV2Response"/&gt;

  &lt;xs:element name="existsTransformerResponse" type="tns:existsTransformerResponse"/&gt;

  &lt;xs:element name="existsTransformerV2" type="tns:existsTransformerV2"/&gt;

  &lt;xs:element name="existsTransformerV2Response" type="tns:existsTransformerV2Response"/&gt;

  &lt;xs:element name="existsView" type="tns:existsView"/&gt;

  &lt;xs:element name="existsViewResponse" type="tns:existsViewResponse"/&gt;

  &lt;xs:element name="extractThroughTransformerV2" type="tns:extractThroughTransformerV2"/&gt;

  &lt;xs:element name="extractThroughTransformerV2Response" type="tns:extractThroughTransformerV2Response"/&gt;

  &lt;xs:element name="extractUsingTransformer" type="tns:extractUsingTransformer"/&gt;

  &lt;xs:element name="extractUsingTransformerResponse" type="tns:extractUsingTransformerResponse"/&gt;

  &lt;xs:element name="extractUsingTransformerThruView" type="tns:extractUsingTransformerThruView"/&gt;

  &lt;xs:element name="extractUsingTransformerThruViewResponse" type="tns:extractUsingTransformerThruViewResponse"/&gt;

  &lt;xs:element name="findAllDroppedItemsPKs" type="tns:findAllDroppedItemsPKs"/&gt;

  &lt;xs:element name="findAllDroppedItemsPKsResponse" type="tns:findAllDroppedItemsPKsResponse"/&gt;

  &lt;xs:element name="findBackgroundJobPKs" type="tns:findBackgroundJobPKs"/&gt;

  &lt;xs:element name="findBackgroundJobPKsResponse" type="tns:findBackgroundJobPKsResponse"/&gt;

  &lt;xs:element name="getAutoIncrement" type="tns:getAutoIncrement"/&gt;

  &lt;xs:element name="getAutoIncrementResponse" type="tns:getAutoIncrementResponse"/&gt;

  &lt;xs:element name="getBackgroundJob" type="tns:getBackgroundJob"/&gt;

  &lt;xs:element name="getBackgroundJobResponse" type="tns:getBackgroundJobResponse"/&gt;

  &lt;xs:element name="getBusinessConceptKey" type="tns:getBusinessConceptKey"/&gt;

  &lt;xs:element name="getBusinessConceptKeyResponse" type="tns:getBusinessConceptKeyResponse"/&gt;

  &lt;xs:element name="getBusinessConceptValue" type="tns:getBusinessConceptValue"/&gt;

  &lt;xs:element name="getBusinessConceptValueResponse" type="tns:getBusinessConceptValueResponse"/&gt;

  &lt;xs:element name="getBusinessConcepts" type="tns:getBusinessConcepts"/&gt;

  &lt;xs:element name="getBusinessConceptsResponse" type="tns:getBusinessConceptsResponse"/&gt;

  &lt;xs:element name="getComponentVersion" type="tns:getComponentVersion"/&gt;

  &lt;xs:element name="getComponentVersionResponse" type="tns:getComponentVersionResponse"/&gt;

  &lt;xs:element name="getConceptsInDataCluster" type="tns:getConceptsInDataCluster"/&gt;

  &lt;xs:element name="getConceptsInDataClusterResponse" type="tns:getConceptsInDataClusterResponse"/&gt;

  &lt;xs:element name="getDataCluster" type="tns:getDataCluster"/&gt;

  &lt;xs:element name="getDataClusterPKs" type="tns:getDataClusterPKs"/&gt;

  &lt;xs:element name="getDataClusterPKsResponse" type="tns:getDataClusterPKsResponse"/&gt;

  &lt;xs:element name="getDataClusterResponse" type="tns:getDataClusterResponse"/&gt;

  &lt;xs:element name="getDataModel" type="tns:getDataModel"/&gt;

  &lt;xs:element name="getDataModelPKs" type="tns:getDataModelPKs"/&gt;

  &lt;xs:element name="getDataModelPKsResponse" type="tns:getDataModelPKsResponse"/&gt;

  &lt;xs:element name="getDataModelResponse" type="tns:getDataModelResponse"/&gt;

  &lt;xs:element name="getDigest" type="tns:getDigest"/&gt;

  &lt;xs:element name="getDigestResponse" type="tns:getDigestResponse"/&gt;

  &lt;xs:element name="getFullPathValues" type="tns:getFullPathValues"/&gt;

  &lt;xs:element name="getFullPathValuesResponse" type="tns:getFullPathValuesResponse"/&gt;

  &lt;xs:element name="getItem" type="tns:getItem"/&gt;

  &lt;xs:element name="getItemPKsByCriteria" type="tns:getItemPKsByCriteria"/&gt;

  &lt;xs:element name="getItemPKsByCriteriaResponse" type="tns:getItemPKsByCriteriaResponse"/&gt;

  &lt;xs:element name="getItemPKsByFullCriteria" type="tns:getItemPKsByFullCriteria"/&gt;

  &lt;xs:element name="getItemPKsByFullCriteriaResponse" type="tns:getItemPKsByFullCriteriaResponse"/&gt;

  &lt;xs:element name="getItemResponse" type="tns:getItemResponse"/&gt;

  &lt;xs:element name="getItems" type="tns:getItems"/&gt;

  &lt;xs:element name="getItemsByCustomFKFilters" type="tns:getItemsByCustomFKFilters"/&gt;

  &lt;xs:element name="getItemsByCustomFKFiltersResponse" type="tns:getItemsByCustomFKFiltersResponse"/&gt;

  &lt;xs:element name="getItemsResponse" type="tns:getItemsResponse"/&gt;

  &lt;xs:element name="getItemsSort" type="tns:getItemsSort"/&gt;

  &lt;xs:element name="getItemsSortResponse" type="tns:getItemsSortResponse"/&gt;

  &lt;xs:element name="getMDMCategory" type="tns:getMDMCategory"/&gt;

  &lt;xs:element name="getMDMCategoryResponse" type="tns:getMDMCategoryResponse"/&gt;

  &lt;xs:element name="getMDMConfiguration" type="tns:getMDMConfiguration"/&gt;

  &lt;xs:element name="getMDMConfigurationResponse" type="tns:getMDMConfigurationResponse"/&gt;

  &lt;xs:element name="getMDMJob" type="tns:getMDMJob"/&gt;

  &lt;xs:element name="getMDMJobResponse" type="tns:getMDMJobResponse"/&gt;

  &lt;xs:element name="getMenu" type="tns:getMenu"/&gt;

  &lt;xs:element name="getMenuPKs" type="tns:getMenuPKs"/&gt;

  &lt;xs:element name="getMenuPKsResponse" type="tns:getMenuPKsResponse"/&gt;

  &lt;xs:element name="getMenuResponse" type="tns:getMenuResponse"/&gt;

  &lt;xs:element name="getRole" type="tns:getRole"/&gt;

  &lt;xs:element name="getRolePKs" type="tns:getRolePKs"/&gt;

  &lt;xs:element name="getRolePKsResponse" type="tns:getRolePKsResponse"/&gt;

  &lt;xs:element name="getRoleResponse" type="tns:getRoleResponse"/&gt;

  &lt;xs:element name="getRoutingOrderV2ByCriteriaWithPaging" type="tns:getRoutingOrderV2ByCriteriaWithPaging"/&gt;

  &lt;xs:element name="getRoutingOrderV2ByCriteriaWithPagingResponse" type="tns:getRoutingOrderV2ByCriteriaWithPagingResponse"/&gt;

  &lt;xs:element name="getRoutingOrderV2PKsByCriteria" type="tns:getRoutingOrderV2PKsByCriteria"/&gt;

  &lt;xs:element name="getRoutingOrderV2PKsByCriteriaResponse" type="tns:getRoutingOrderV2PKsByCriteriaResponse"/&gt;

  &lt;xs:element name="getRoutingOrderV2SByCriteria" type="tns:getRoutingOrderV2SByCriteria"/&gt;

  &lt;xs:element name="getRoutingOrderV2SByCriteriaResponse" type="tns:getRoutingOrderV2SByCriteriaResponse"/&gt;

  &lt;xs:element name="getRoutingRule" type="tns:getRoutingRule"/&gt;

  &lt;xs:element name="getRoutingRulePKs" type="tns:getRoutingRulePKs"/&gt;

  &lt;xs:element name="getRoutingRulePKsResponse" type="tns:getRoutingRulePKsResponse"/&gt;

  &lt;xs:element name="getRoutingRuleResponse" type="tns:getRoutingRuleResponse"/&gt;

  &lt;xs:element name="getServiceConfiguration" type="tns:getServiceConfiguration"/&gt;

  &lt;xs:element name="getServiceConfigurationResponse" type="tns:getServiceConfigurationResponse"/&gt;

  &lt;xs:element name="getServiceDocument" type="tns:getServiceDocument"/&gt;

  &lt;xs:element name="getServiceDocumentResponse" type="tns:getServiceDocumentResponse"/&gt;

  &lt;xs:element name="getServicesList" type="tns:getServicesList"/&gt;

  &lt;xs:element name="getServicesListResponse" type="tns:getServicesListResponse"/&gt;

  &lt;xs:element name="getStoredProcedure" type="tns:getStoredProcedure"/&gt;

  &lt;xs:element name="getStoredProcedurePKs" type="tns:getStoredProcedurePKs"/&gt;

  &lt;xs:element name="getStoredProcedurePKsResponse" type="tns:getStoredProcedurePKsResponse"/&gt;

  &lt;xs:element name="getStoredProcedureResponse" type="tns:getStoredProcedureResponse"/&gt;

  &lt;xs:element name="getTransformer" type="tns:getTransformer"/&gt;

  &lt;xs:element name="getTransformerPKs" type="tns:getTransformerPKs"/&gt;

  &lt;xs:element name="getTransformerPKsResponse" type="tns:getTransformerPKsResponse"/&gt;

  &lt;xs:element name="getTransformerPluginV2Configuration" type="tns:getTransformerPluginV2Configuration"/&gt;

  &lt;xs:element name="getTransformerPluginV2ConfigurationResponse" type="tns:getTransformerPluginV2ConfigurationResponse"/&gt;

  &lt;xs:element name="getTransformerPluginV2Details" type="tns:getTransformerPluginV2Details"/&gt;

  &lt;xs:element name="getTransformerPluginV2DetailsResponse" type="tns:getTransformerPluginV2DetailsResponse"/&gt;

  &lt;xs:element name="getTransformerPluginV2SList" type="tns:getTransformerPluginV2SList"/&gt;

  &lt;xs:element name="getTransformerPluginV2SListResponse" type="tns:getTransformerPluginV2SListResponse"/&gt;

  &lt;xs:element name="getTransformerResponse" type="tns:getTransformerResponse"/&gt;

  &lt;xs:element name="getTransformerV2" type="tns:getTransformerV2"/&gt;

  &lt;xs:element name="getTransformerV2PKs" type="tns:getTransformerV2PKs"/&gt;

  &lt;xs:element name="getTransformerV2PKsResponse" type="tns:getTransformerV2PKsResponse"/&gt;

  &lt;xs:element name="getTransformerV2Response" type="tns:getTransformerV2Response"/&gt;

  &lt;xs:element name="getView" type="tns:getView"/&gt;

  &lt;xs:element name="getViewPKs" type="tns:getViewPKs"/&gt;

  &lt;xs:element name="getViewPKsResponse" type="tns:getViewPKsResponse"/&gt;

  &lt;xs:element name="getViewResponse" type="tns:getViewResponse"/&gt;

  &lt;xs:element name="initMDM" type="tns:initMDM"/&gt;

  &lt;xs:element name="initMDMResponse" type="tns:initMDMResponse"/&gt;

  &lt;xs:element name="isItemModifiedByOther" type="tns:isItemModifiedByOther"/&gt;

  &lt;xs:element name="isItemModifiedByOtherResponse" type="tns:isItemModifiedByOtherResponse"/&gt;

  &lt;xs:element name="isPagingAccurate" type="tns:isPagingAccurate"/&gt;

  &lt;xs:element name="isPagingAccurateResponse" type="tns:isPagingAccurateResponse"/&gt;

  &lt;xs:element name="loadDroppedItem" type="tns:loadDroppedItem"/&gt;

  &lt;xs:element name="loadDroppedItemResponse" type="tns:loadDroppedItemResponse"/&gt;

  &lt;xs:element name="logout" type="tns:logout"/&gt;

  &lt;xs:element name="logoutResponse" type="tns:logoutResponse"/&gt;

  &lt;xs:element name="partialPutItem" type="tns:partialPutItem"/&gt;

  &lt;xs:element name="partialPutItemResponse" type="tns:partialPutItemResponse"/&gt;

  &lt;xs:element name="ping" type="tns:ping"/&gt;

  &lt;xs:element name="pingResponse" type="tns:pingResponse"/&gt;

  &lt;xs:element name="processBytesUsingTransformer" type="tns:processBytesUsingTransformer"/&gt;

  &lt;xs:element name="processBytesUsingTransformerAsBackgroundJob" type="tns:processBytesUsingTransformerAsBackgroundJob"/&gt;

  &lt;xs:element name="processBytesUsingTransformerAsBackgroundJobResponse" type="tns:processBytesUsingTransformerAsBackgroundJobResponse"/&gt;

  &lt;xs:element name="processBytesUsingTransformerResponse" type="tns:processBytesUsingTransformerResponse"/&gt;

  &lt;xs:element name="processFileUsingTransformer" type="tns:processFileUsingTransformer"/&gt;

  &lt;xs:element name="processFileUsingTransformerAsBackgroundJob" type="tns:processFileUsingTransformerAsBackgroundJob"/&gt;

  &lt;xs:element name="processFileUsingTransformerAsBackgroundJobResponse" type="tns:processFileUsingTransformerAsBackgroundJobResponse"/&gt;

  &lt;xs:element name="processFileUsingTransformerResponse" type="tns:processFileUsingTransformerResponse"/&gt;

  &lt;xs:element name="putBackgroundJob" type="tns:putBackgroundJob"/&gt;

  &lt;xs:element name="putBackgroundJobResponse" type="tns:putBackgroundJobResponse"/&gt;

  &lt;xs:element name="putBusinessConcept" type="tns:putBusinessConcept"/&gt;

  &lt;xs:element name="putBusinessConceptResponse" type="tns:putBusinessConceptResponse"/&gt;

  &lt;xs:element name="putBusinessConceptSchema" type="tns:putBusinessConceptSchema"/&gt;

  &lt;xs:element name="putBusinessConceptSchemaResponse" type="tns:putBusinessConceptSchemaResponse"/&gt;

  &lt;xs:element name="putDBDataCluster" type="tns:putDBDataCluster"/&gt;

  &lt;xs:element name="putDBDataClusterResponse" type="tns:putDBDataClusterResponse"/&gt;

  &lt;xs:element name="putDataCluster" type="tns:putDataCluster"/&gt;

  &lt;xs:element name="putDataClusterResponse" type="tns:putDataClusterResponse"/&gt;

  &lt;xs:element name="putDataModel" type="tns:putDataModel"/&gt;

  &lt;xs:element name="putDataModelResponse" type="tns:putDataModelResponse"/&gt;

  &lt;xs:element name="putItem" type="tns:putItem"/&gt;

  &lt;xs:element name="putItemArray" type="tns:putItemArray"/&gt;

  &lt;xs:element name="putItemArrayResponse" type="tns:putItemArrayResponse"/&gt;

  &lt;xs:element name="putItemResponse" type="tns:putItemResponse"/&gt;

  &lt;xs:element name="putItemWithCustomReport" type="tns:putItemWithCustomReport"/&gt;

  &lt;xs:element name="putItemWithCustomReportResponse" type="tns:putItemWithCustomReportResponse"/&gt;

  &lt;xs:element name="putItemWithReport" type="tns:putItemWithReport"/&gt;

  &lt;xs:element name="putItemWithReportArray" type="tns:putItemWithReportArray"/&gt;

  &lt;xs:element name="putItemWithReportArrayResponse" type="tns:putItemWithReportArrayResponse"/&gt;

  &lt;xs:element name="putItemWithReportResponse" type="tns:putItemWithReportResponse"/&gt;

  &lt;xs:element name="putMenu" type="tns:putMenu"/&gt;

  &lt;xs:element name="putMenuResponse" type="tns:putMenuResponse"/&gt;

  &lt;xs:element name="putRole" type="tns:putRole"/&gt;

  &lt;xs:element name="putRoleResponse" type="tns:putRoleResponse"/&gt;

  &lt;xs:element name="putRoutingRule" type="tns:putRoutingRule"/&gt;

  &lt;xs:element name="putRoutingRuleResponse" type="tns:putRoutingRuleResponse"/&gt;

  &lt;xs:element name="putServiceConfiguration" type="tns:putServiceConfiguration"/&gt;

  &lt;xs:element name="putServiceConfigurationResponse" type="tns:putServiceConfigurationResponse"/&gt;

  &lt;xs:element name="putStoredProcedure" type="tns:putStoredProcedure"/&gt;

  &lt;xs:element name="putStoredProcedureResponse" type="tns:putStoredProcedureResponse"/&gt;

  &lt;xs:element name="putTransformer" type="tns:putTransformer"/&gt;

  &lt;xs:element name="putTransformerPluginV2Configuration" type="tns:putTransformerPluginV2Configuration"/&gt;

  &lt;xs:element name="putTransformerPluginV2ConfigurationResponse" type="tns:putTransformerPluginV2ConfigurationResponse"/&gt;

  &lt;xs:element name="putTransformerResponse" type="tns:putTransformerResponse"/&gt;

  &lt;xs:element name="putTransformerV2" type="tns:putTransformerV2"/&gt;

  &lt;xs:element name="putTransformerV2Response" type="tns:putTransformerV2Response"/&gt;

  &lt;xs:element name="putView" type="tns:putView"/&gt;

  &lt;xs:element name="putViewResponse" type="tns:putViewResponse"/&gt;

  &lt;xs:element name="quickSearch" type="tns:quickSearch"/&gt;

  &lt;xs:element name="quickSearchResponse" type="tns:quickSearchResponse"/&gt;

  &lt;xs:element name="recoverDroppedItem" type="tns:recoverDroppedItem"/&gt;

  &lt;xs:element name="recoverDroppedItemResponse" type="tns:recoverDroppedItemResponse"/&gt;

  &lt;xs:element name="removeDroppedItem" type="tns:removeDroppedItem"/&gt;

  &lt;xs:element name="removeDroppedItemResponse" type="tns:removeDroppedItemResponse"/&gt;

  &lt;xs:element name="routeItemV2" type="tns:routeItemV2"/&gt;

  &lt;xs:element name="routeItemV2Response" type="tns:routeItemV2Response"/&gt;

  &lt;xs:element name="routingEngineV2Action" type="tns:routingEngineV2Action"/&gt;

  &lt;xs:element name="routingEngineV2ActionResponse" type="tns:routingEngineV2ActionResponse"/&gt;

  &lt;xs:element name="runQuery" type="tns:runQuery"/&gt;

  &lt;xs:element name="runQueryResponse" type="tns:runQueryResponse"/&gt;

  &lt;xs:element name="serviceAction" type="tns:serviceAction"/&gt;

  &lt;xs:element name="serviceActionResponse" type="tns:serviceActionResponse"/&gt;

  &lt;xs:element name="supportStaging" type="tns:supportStaging"/&gt;

  &lt;xs:element name="supportStagingResponse" type="tns:supportStagingResponse"/&gt;

  &lt;xs:element name="updateDigest" type="tns:updateDigest"/&gt;

  &lt;xs:element name="updateDigestResponse" type="tns:updateDigestResponse"/&gt;

  &lt;xs:element name="updateItemMetadata" type="tns:updateItemMetadata"/&gt;

  &lt;xs:element name="updateItemMetadataResponse" type="tns:updateItemMetadataResponse"/&gt;

  &lt;xs:element name="viewSearch" type="tns:viewSearch"/&gt;

  &lt;xs:element name="viewSearchResponse" type="tns:viewSearchResponse"/&gt;

  &lt;xs:element name="xPathsSearch" type="tns:xPathsSearch"/&gt;

  &lt;xs:element name="xPathsSearchResponse" type="tns:xPathsSearchResponse"/&gt;

  &lt;xs:complexType name="putItemWithReportArray"&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element minOccurs="0" name="arg0" type="tns:WSPutItemWithReportArray"/&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;

  &lt;xs:complexType name="WSPutItemWithReportArray"&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element maxOccurs="unbounded" minOccurs="0" name="wsPutItem" nillable="true" type="tns:WSPutItemWithReport"/&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;

  &lt;xs:complexType name="WSPutItemWithReport"&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element minOccurs="0" name="invokeBeforeSaving" type="xs:boolean"/&gt;
      &lt;xs:element minOccurs="0" name="source" type="xs:string"/&gt;
      &lt;xs:element minOccurs="0" name="wsPutItem" type="tns:WSPutItem"/&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;

  &lt;xs:complexType name="WSPutItem"&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element minOccurs="0" name="isUpdate" type="xs:boolean"/&gt;
      &lt;xs:element minOccurs="0" name="wsDataClusterPK" type="tns:WSDataClusterPK"/&gt;
      &lt;xs:element minOccurs="0" name="wsDataModelPK" type="tns:WSDataModelPK"/&gt;
      &lt;xs:element minOccurs="0" name="xmlString" type="xs:string"/&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;

  &lt;xs:complexType name="WSDataClusterPK"&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element minOccurs="0" name="pk" type="xs:string"/&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;

  &lt;xs:complexType name="WSDataModelPK"&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element minOccurs="0" name="pk" type="xs:string"/&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;

  &lt;xs:complexType name="putItemWithReportArrayResponse"&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element minOccurs="0" name="return" type="tns:WSItemPKArray"/&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;

  &lt;xs:complexType name="WSItemPKArray"&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element maxOccurs="unbounded" minOccurs="0" name="wsItemPK" nillable="true" type="tns:WSItemPK"/&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;

  &lt;xs:complexType name="WSItemPK"&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element minOccurs="0" name="conceptName" type="xs:string"/&gt;
      &lt;xs:element maxOccurs="unbounded" minOccurs="0" name="ids" nillable="true" type="xs:string"/&gt;
      &lt;xs:element minOccurs="0" name="wsDataClusterPK" type="tns:WSDataClusterPK"/&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;

  &lt;xs:complexType name="getMDMJob"&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element minOccurs="0" name="arg0" type="tns:WSMDMNULL"/&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;

  &lt;xs:complexType name="WSMDMNULL"&gt;
    &lt;xs:sequence/&gt;
  &lt;/xs:complexType&gt;

  &lt;xs:complexType name="getMDMJobResponse"&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element minOccurs="0" name="return" type="tns:WSMDMJobArray"/&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;

  &lt;xs:complexType name="WSMDMJobArray"&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element maxOccurs="unbounded" minOccurs="0" name="wsMDMJob" nillable="true" type="tns:WSMDMJob"/&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;

  &lt;xs:complexType name="WSMDMJob"&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element minOccurs="0" name="jobName" type="xs:string"/&gt;
      &lt;xs:element minOccurs="0" name="jobVersion" type="xs:string"/&gt;
      &lt;xs:element minOccurs="0" name="suffix" type="xs:string"/&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;

  &lt;xs:complexType name="getTransformerPluginV2Configuration"&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element minOccurs="0" name="arg0" type="tns:WSTransformerPluginV2GetConfiguration"/&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;

  &lt;xs:complexType name="WSTransformerPluginV2GetConfiguration"&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element minOccurs="0" name="jndiName" type="xs:string"/&gt;
      &lt;xs:element minOccurs="0" name="optionalParameter" type="xs:string"/&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;

  &lt;xs:complexType name="getTransformerPluginV2ConfigurationResponse"&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element minOccurs="0" name="return" type="tns:WSString"/&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;

  &lt;xs:complexType name="WSString"&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element minOccurs="0" name="value" type="xs:string"/&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;

  &lt;xs:complexType name="findBackgroundJobPKs"&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element minOccurs="0" name="arg0" type="tns:WSFindBackgroundJobPKs"/&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;

  &lt;xs:complexType name="WSFindBackgroundJobPKs"&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element minOccurs="0" name="status" type="tns:BackgroundJobStatusType"/&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;

  &lt;xs:complexType name="findBackgroundJobPKsResponse"&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element minOccurs="0" name="return" type="tns:WSBackgroundJobPKArray"/&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;

  &lt;xs:complexType name="WSBackgroundJobPKArray"&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element maxOccurs="unbounded" minOccurs="0" name="wsBackgroundJobPK" nillable="true" type="tns:WSBackgroundJobPK"/&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;

  &lt;xs:complexType name="WSBackgroundJobPK"&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element minOccurs="0" name="pk" type="xs:string"/&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;

  &lt;xs:complexType name="existsTransformerV2"&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element minOccurs="0" name="arg0" type="tns:WSExistsTransformerV2"/&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;

  &lt;xs:complexType name="WSExistsTransformerV2"&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element minOccurs="0" name="wsTransformerV2PK" type="tns:WSTransformerV2PK"/&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;

  &lt;xs:complexType name="WSTransformerV2PK"&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element minOccurs="0" name="pk" type="xs:string"/&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;

  &lt;xs:complexType name="existsTransformerV2Response"&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element minOccurs="0" name="return" type="tns:WSBoolean"/&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;

  &lt;xs:complexType name="WSBoolean"&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element name="_true" type="xs:boolean"/&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;

  &lt;xs:complexType name="deleteStoredProcedure"&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element minOccurs="0" name="arg0" type="tns:WSDeleteStoredProcedure"/&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;

  &lt;xs:complexType name="WSDeleteStoredProcedure"&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element minOccurs="0" name="wsStoredProcedurePK" type="tns:WSStoredProcedurePK"/&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;

  &lt;xs:complexType name="WSStoredProcedurePK"&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element minOccurs="0" name="pk" type="xs:string"/&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;

  &lt;xs:complexType name="deleteStoredProcedureResponse"&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element minOccurs="0" name="return" type="tns:WSStoredProcedurePK"/&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;

  &lt;xs:complexType name="removeDroppedItem"&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element minOccurs="0" name="arg0" type="tns:WSRemoveDroppedItem"/&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;

  &lt;xs:complexType name="WSRemoveDroppedItem"&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element minOccurs="0" name="wsDroppedItemPK" type="tns:WSDroppedItemPK"/&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;

  &lt;xs:complexType name="WSDroppedItemPK"&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element minOccurs="0" name="partPath" type="xs:string"/&gt;
      &lt;xs:element minOccurs="0" name="wsItemPK" type="tns:WSItemPK"/&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;

  &lt;xs:complexType name="removeDroppedItemResponse"&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element minOccurs="0" name="return" type="tns:WSDroppedItemPK"/&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;

  &lt;xs:complexType name="deleteItems"&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element minOccurs="0" name="arg0" type="tns:WSDeleteItems"/&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;

  &lt;xs:complexType name="WSDeleteItems"&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element minOccurs="0" name="conceptName" type="xs:string"/&gt;
      &lt;xs:element minOccurs="0" name="override" type="xs:boolean"/&gt;
      &lt;xs:element name="spellTreshold" type="xs:int"/&gt;
      &lt;xs:element minOccurs="0" name="wsDataClusterPK" type="tns:WSDataClusterPK"/&gt;
      &lt;xs:element minOccurs="0" name="wsWhereItem" type="tns:WSWhereItem"/&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;

  &lt;xs:complexType name="WSWhereItem"&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element minOccurs="0" name="whereAnd" type="tns:WSWhereAnd"/&gt;
      &lt;xs:element minOccurs="0" name="whereCondition" type="tns:WSWhereCondition"/&gt;
      &lt;xs:element minOccurs="0" name="whereOr" type="tns:WSWhereOr"/&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;

  &lt;xs:complexType name="WSWhereAnd"&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element maxOccurs="unbounded" minOccurs="0" name="whereItems" nillable="true" type="tns:WSWhereItem"/&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;

  &lt;xs:complexType name="WSWhereCondition"&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element minOccurs="0" name="leftPath" type="xs:string"/&gt;
      &lt;xs:element minOccurs="0" name="operator" type="tns:WSWhereOperator"/&gt;
      &lt;xs:element minOccurs="0" name="rightValueOrPath" type="xs:string"/&gt;
      &lt;xs:element name="spellCheck" type="xs:boolean"/&gt;
      &lt;xs:element minOccurs="0" name="stringPredicate" type="tns:WSStringPredicate"/&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;

  &lt;xs:complexType name="WSWhereOr"&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element maxOccurs="unbounded" minOccurs="0" name="whereItems" nillable="true" type="tns:WSWhereItem"/&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;

  &lt;xs:complexType name="deleteItemsResponse"&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element minOccurs="0" name="return" type="tns:WSInt"/&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;

  &lt;xs:complexType name="WSInt"&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element name="value" type="xs:int"/&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;

  &lt;xs:complexType name="putItemWithReport"&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element minOccurs="0" name="arg0" type="tns:WSPutItemWithReport"/&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;

  &lt;xs:complexType name="putItemWithReportResponse"&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element minOccurs="0" name="return" type="tns:WSItemPK"/&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;

  &lt;xs:complexType name="dropItem"&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element minOccurs="0" name="arg0" type="tns:WSDropItem"/&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;

  &lt;xs:complexType name="WSDropItem"&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element minOccurs="0" name="invokeBeforeDeleting" type="xs:boolean"/&gt;
      &lt;xs:element minOccurs="0" name="override" type="xs:boolean"/&gt;
      &lt;xs:element minOccurs="0" name="partPath" type="xs:string"/&gt;
      &lt;xs:element minOccurs="0" name="source" type="xs:string"/&gt;
      &lt;xs:element minOccurs="0" name="withReport" type="xs:boolean"/&gt;
      &lt;xs:element minOccurs="0" name="wsItemPK" type="tns:WSItemPK"/&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;

  &lt;xs:complexType name="dropItemResponse"&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element minOccurs="0" name="return" type="tns:WSDroppedItemPK"/&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;

  &lt;xs:complexType name="getTransformerV2"&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element minOccurs="0" name="arg0" type="tns:WSGetTransformerV2"/&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;

  &lt;xs:complexType name="WSGetTransformerV2"&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element minOccurs="0" name="wsTransformerV2PK" type="tns:WSTransformerV2PK"/&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;

  &lt;xs:complexType name="getTransformerV2Response"&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element minOccurs="0" name="return" type="tns:WSTransformerV2"/&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;

  &lt;xs:complexType name="WSTransformerV2"&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element minOccurs="0" name="description" type="xs:string"/&gt;
      &lt;xs:element minOccurs="0" name="name" type="xs:string"/&gt;
      &lt;xs:element maxOccurs="unbounded" minOccurs="0" name="processSteps" nillable="true" type="tns:WSTransformerProcessStep"/&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;

  &lt;xs:complexType name="WSTransformerProcessStep"&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element minOccurs="0" name="description" type="xs:string"/&gt;
      &lt;xs:element minOccurs="0" name="disabled" type="xs:boolean"/&gt;
      &lt;xs:element maxOccurs="unbounded" minOccurs="0" name="inputMappings" nillable="true" type="tns:WSTransformerVariablesMapping"/&gt;
      &lt;xs:element maxOccurs="unbounded" minOccurs="0" name="outputMappings" nillable="true" type="tns:WSTransformerVariablesMapping"/&gt;
      &lt;xs:element minOccurs="0" name="parameters" type="xs:string"/&gt;
      &lt;xs:element minOccurs="0" name="pluginJNDI" type="xs:string"/&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;

  &lt;xs:complexType name="WSTransformerVariablesMapping"&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element minOccurs="0" name="hardCoding" type="tns:WSTypedContent"/&gt;
      &lt;xs:element minOccurs="0" name="pipelineVariable" type="xs:string"/&gt;
      &lt;xs:element minOccurs="0" name="pluginVariable" type="xs:string"/&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;

  &lt;xs:complexType name="WSTypedContent"&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element minOccurs="0" name="contentType" type="xs:string"/&gt;
      &lt;xs:element minOccurs="0" name="url" type="xs:string"/&gt;
      &lt;xs:element minOccurs="0" name="wsBytes" type="tns:WSByteArray"/&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;

  &lt;xs:complexType name="WSByteArray"&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element minOccurs="0" name="bytes" type="xs:base64Binary"/&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;

  &lt;xs:complexType name="existsTransformerPluginV2"&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element minOccurs="0" name="arg0" type="tns:WSExistsTransformerPluginV2"/&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;

  &lt;xs:complexType name="WSExistsTransformerPluginV2"&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element minOccurs="0" name="jndiName" type="xs:string"/&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;

  &lt;xs:complexType name="existsTransformerPluginV2Response"&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element minOccurs="0" name="return" type="tns:WSBoolean"/&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;

  &lt;xs:complexType name="deleteBusinessConcept"&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element minOccurs="0" name="arg0" type="tns:WSDeleteBusinessConcept"/&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;

  &lt;xs:complexType name="WSDeleteBusinessConcept"&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element minOccurs="0" name="businessConceptName" type="xs:string"/&gt;
      &lt;xs:element minOccurs="0" name="wsDataModelPK" type="tns:WSDataModelPK"/&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;

  &lt;xs:complexType name="deleteBusinessConceptResponse"&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element minOccurs="0" name="return" type="tns:WSString"/&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;

  &lt;xs:complexType name="putItemArray"&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element minOccurs="0" name="arg0" type="tns:WSPutItemArray"/&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;

  &lt;xs:complexType name="WSPutItemArray"&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element maxOccurs="unbounded" minOccurs="0" name="wsPutItem" nillable="true" type="tns:WSPutItem"/&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;

  &lt;xs:complexType name="putItemArrayResponse"&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element minOccurs="0" name="return" type="tns:WSItemPKArray"/&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;

  &lt;xs:complexType name="executeRoutingOrderV2Synchronously"&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element minOccurs="0" name="arg0" type="tns:WSExecuteRoutingOrderV2Synchronously"/&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;

  &lt;xs:complexType name="WSExecuteRoutingOrderV2Synchronously"&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element minOccurs="0" name="routingOrderV2PK" type="tns:WSRoutingOrderV2PK"/&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;

  &lt;xs:complexType name="WSRoutingOrderV2PK"&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element minOccurs="0" name="name" type="xs:string"/&gt;
      &lt;xs:element minOccurs="0" name="status" type="tns:WSRoutingOrderV2Status"/&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;

  &lt;xs:complexType name="executeRoutingOrderV2SynchronouslyResponse"&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element minOccurs="0" name="return" type="tns:WSString"/&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;

  &lt;xs:complexType name="getMenu"&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element minOccurs="0" name="arg0" type="tns:WSGetMenu"/&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;

  &lt;xs:complexType name="WSGetMenu"&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element minOccurs="0" name="wsMenuPK" type="tns:WSMenuPK"/&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;

  &lt;xs:complexType name="WSMenuPK"&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element minOccurs="0" name="pk" type="xs:string"/&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;

  &lt;xs:complexType name="getMenuResponse"&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element minOccurs="0" name="return" type="tns:WSMenu"/&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;

  &lt;xs:complexType name="WSMenu"&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element minOccurs="0" name="description" type="xs:string"/&gt;
      &lt;xs:element maxOccurs="unbounded" minOccurs="0" name="menuEntries" nillable="true" type="tns:WSMenuEntry"/&gt;
      &lt;xs:element minOccurs="0" name="name" type="xs:string"/&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;

  &lt;xs:complexType name="WSMenuEntry"&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element minOccurs="0" name="application" type="xs:string"/&gt;
      &lt;xs:element minOccurs="0" name="context" type="xs:string"/&gt;
      &lt;xs:element maxOccurs="unbounded" minOccurs="0" name="descriptions" nillable="true" type="tns:WSMenuMenuEntriesDescriptions"/&gt;
      &lt;xs:element minOccurs="0" name="icon" type="xs:string"/&gt;
      &lt;xs:element minOccurs="0" name="id" type="xs:string"/&gt;
      &lt;xs:element maxOccurs="unbounded" minOccurs="0" name="subMenus" nillable="true" type="tns:WSMenuEntry"/&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;

  &lt;xs:complexType name="WSMenuMenuEntriesDescriptions"&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element minOccurs="0" name="label" type="xs:string"/&gt;
      &lt;xs:element minOccurs="0" name="language" type="xs:string"/&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;

  &lt;xs:complexType name="viewSearch"&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element minOccurs="0" name="arg0" type="tns:WSViewSearch"/&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;

  &lt;xs:complexType name="WSViewSearch"&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element minOccurs="0" name="direction" type="xs:string"/&gt;
      &lt;xs:element name="maxItems" type="xs:int"/&gt;
      &lt;xs:element minOccurs="0" name="orderBy" type="xs:string"/&gt;
      &lt;xs:element name="skip" type="xs:int"/&gt;
      &lt;xs:element name="spellTreshold" type="xs:int"/&gt;
      &lt;xs:element minOccurs="0" name="whereItem" type="tns:WSWhereItem"/&gt;
      &lt;xs:element minOccurs="0" name="wsDataClusterPK" type="tns:WSDataClusterPK"/&gt;
      &lt;xs:element minOccurs="0" name="wsViewPK" type="tns:WSViewPK"/&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;

  &lt;xs:complexType name="WSViewPK"&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element minOccurs="0" name="pk" type="xs:string"/&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;

  &lt;xs:complexType name="viewSearchResponse"&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element minOccurs="0" name="return" type="tns:WSStringArray"/&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;

  &lt;xs:complexType name="WSStringArray"&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element maxOccurs="unbounded" minOccurs="0" name="strings" nillable="true" type="xs:string"/&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;

  &lt;xs:complexType name="getItemsByCustomFKFilters"&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element minOccurs="0" name="arg0" type="tns:WSGetItemsByCustomFKFilters"/&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;

  &lt;xs:complexType name="WSGetItemsByCustomFKFilters"&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element minOccurs="0" name="conceptName" type="xs:string"/&gt;
      &lt;xs:element minOccurs="0" name="direction" type="xs:string"/&gt;
      &lt;xs:element minOccurs="0" name="injectedXpath" type="xs:string"/&gt;
      &lt;xs:element name="maxItems" type="xs:int"/&gt;
      &lt;xs:element minOccurs="0" name="orderBy" type="xs:string"/&gt;
      &lt;xs:element name="returnCount" type="xs:boolean"/&gt;
      &lt;xs:element name="skip" type="xs:int"/&gt;
      &lt;xs:element minOccurs="0" name="viewablePaths" type="tns:WSStringArray"/&gt;
      &lt;xs:element minOccurs="0" name="whereItem" type="tns:WSWhereItem"/&gt;
      &lt;xs:element minOccurs="0" name="wsDataClusterPK" type="tns:WSDataClusterPK"/&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;

  &lt;xs:complexType name="getItemsByCustomFKFiltersResponse"&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element minOccurs="0" name="return" type="tns:WSStringArray"/&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;

  &lt;xs:complexType name="supportStaging"&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element minOccurs="0" name="arg0" type="tns:WSDataClusterPK"/&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;

  &lt;xs:complexType name="supportStagingResponse"&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element minOccurs="0" name="return" type="tns:WSBoolean"/&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;

  &lt;xs:complexType name="processBytesUsingTransformer"&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element minOccurs="0" name="arg0" type="tns:WSProcessBytesUsingTransformer"/&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;

  &lt;xs:complexType name="WSProcessBytesUsingTransformer"&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element minOccurs="0" name="contentType" type="xs:string"/&gt;
      &lt;xs:element minOccurs="0" name="wsBytes" type="tns:WSByteArray"/&gt;
      &lt;xs:element minOccurs="0" name="wsOutputDecisionTable" type="tns:WSOutputDecisionTable"/&gt;
      &lt;xs:element minOccurs="0" name="wsTransformerPK" type="tns:WSTransformerPK"/&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;

  &lt;xs:complexType name="WSOutputDecisionTable"&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element maxOccurs="unbounded" minOccurs="0" name="decisions" nillable="true" type="tns:WSProcessBytesUsingTransformerWsOutputDecisionTableDecisions"/&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;

  &lt;xs:complexType name="WSProcessBytesUsingTransformerWsOutputDecisionTableDecisions"&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element minOccurs="0" name="decision" type="xs:string"/&gt;
      &lt;xs:element minOccurs="0" name="outputVariableName" type="xs:string"/&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;

  &lt;xs:complexType name="WSTransformerPK"&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element minOccurs="0" name="pk" type="xs:string"/&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;

  &lt;xs:complexType name="processBytesUsingTransformerResponse"&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element minOccurs="0" name="return" type="tns:WSPipeline"/&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;

  &lt;xs:complexType name="WSPipeline"&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element maxOccurs="unbounded" minOccurs="0" name="typedContentEntry" nillable="true" type="tns:WSPipelineTypedContentEntry"/&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;

  &lt;xs:complexType name="WSPipelineTypedContentEntry"&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element minOccurs="0" name="output" type="xs:string"/&gt;
      &lt;xs:element minOccurs="0" name="wsExtractedContent" type="tns:WSExtractedContent"/&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;

  &lt;xs:complexType name="WSExtractedContent"&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element minOccurs="0" name="contentType" type="xs:string"/&gt;
      &lt;xs:element minOccurs="0" name="wsByteArray" type="tns:WSByteArray"/&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;

  &lt;xs:complexType name="deleteItem"&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element minOccurs="0" name="arg0" type="tns:WSDeleteItem"/&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;

  &lt;xs:complexType name="WSDeleteItem"&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element minOccurs="0" name="invokeBeforeDeleting" type="xs:boolean"/&gt;
      &lt;xs:element minOccurs="0" name="override" type="xs:boolean"/&gt;
      &lt;xs:element minOccurs="0" name="source" type="xs:string"/&gt;
      &lt;xs:element minOccurs="0" name="withReport" type="xs:boolean"/&gt;
      &lt;xs:element minOccurs="0" name="wsItemPK" type="tns:WSItemPK"/&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;

  &lt;xs:complexType name="deleteItemResponse"&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element minOccurs="0" name="return" type="tns:WSItemPK"/&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;

  &lt;xs:complexType name="checkFKIntegrity"&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element minOccurs="0" name="arg0" type="tns:WSDeleteItem"/&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;

  &lt;xs:complexType name="checkFKIntegrityResponse"&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element minOccurs="0" name="return" type="tns:fkIntegrityCheckResult"/&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;

  &lt;xs:complexType name="executeTransformerV2"&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element minOccurs="0" name="arg0" type="tns:WSExecuteTransformerV2"/&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;

  &lt;xs:complexType name="WSExecuteTransformerV2"&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element minOccurs="0" name="wsTransformerContext" type="tns:WSTransformerContext"/&gt;
      &lt;xs:element minOccurs="0" name="wsTypedContent" type="tns:WSTypedContent"/&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;

  &lt;xs:complexType name="WSTransformerContext"&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element minOccurs="0" name="pipeline" type="tns:WSTransformerContextPipeline"/&gt;
      &lt;xs:element minOccurs="0" name="projectedItemPKs" type="tns:WSTransformerContextProjectedItemPKs"/&gt;
      &lt;xs:element minOccurs="0" name="wsTransformerPK" type="tns:WSTransformerV2PK"/&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;

  &lt;xs:complexType name="WSTransformerContextPipeline"&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element maxOccurs="unbounded" minOccurs="0" name="pipelineItem" nillable="true" type="tns:WSTransformerContextPipelinePipelineItem"/&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;

  &lt;xs:complexType name="WSTransformerContextPipelinePipelineItem"&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element minOccurs="0" name="variable" type="xs:string"/&gt;
      &lt;xs:element minOccurs="0" name="wsTypedContent" type="tns:WSTypedContent"/&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;

  &lt;xs:complexType name="WSTransformerContextProjectedItemPKs"&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element maxOccurs="unbounded" minOccurs="0" name="wsItemPOJOPK" nillable="true" type="tns:WSItemPK"/&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;

  &lt;xs:complexType name="executeTransformerV2Response"&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element minOccurs="0" name="return" type="tns:WSTransformerContext"/&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;

  &lt;xs:complexType name="putView"&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element minOccurs="0" name="arg0" type="tns:WSPutView"/&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;

  &lt;xs:complexType name="WSPutView"&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element minOccurs="0" name="wsView" type="tns:WSView"/&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;

  &lt;xs:complexType name="WSView"&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element minOccurs="0" name="description" type="xs:string"/&gt;
      &lt;xs:element minOccurs="0" name="isTransformerActive" type="tns:WSBoolean"/&gt;
      &lt;xs:element minOccurs="0" name="name" type="xs:string"/&gt;
      &lt;xs:element maxOccurs="unbounded" minOccurs="0" name="searchableBusinessElements" nillable="true" type="xs:string"/&gt;
      &lt;xs:element minOccurs="0" name="transformerPK" type="xs:string"/&gt;
      &lt;xs:element maxOccurs="unbounded" minOccurs="0" name="viewableBusinessElements" nillable="true" type="xs:string"/&gt;
      &lt;xs:element maxOccurs="unbounded" minOccurs="0" name="whereConditions" nillable="true" type="tns:WSWhereCondition"/&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;

  &lt;xs:complexType name="putViewResponse"&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element minOccurs="0" name="return" type="tns:WSViewPK"/&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;

  &lt;xs:complexType name="getTransformerPKs"&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element minOccurs="0" name="arg0" type="tns:WSGetTransformerPKs"/&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;

  &lt;xs:complexType name="WSGetTransformerPKs"&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element minOccurs="0" name="regex" type="xs:string"/&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;

  &lt;xs:complexType name="getTransformerPKsResponse"&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element minOccurs="0" name="return" type="tns:WSTransformerPKArray"/&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;

  &lt;xs:complexType name="WSTransformerPKArray"&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element maxOccurs="unbounded" minOccurs="0" name="wsTransformerPK" nillable="true" type="tns:WSTransformerPK"/&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;

  &lt;xs:complexType name="existsStoredProcedure"&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element minOccurs="0" name="arg0" type="tns:WSExistsStoredProcedure"/&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;

  &lt;xs:complexType name="WSExistsStoredProcedure"&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element minOccurs="0" name="wsStoredProcedurePK" type="tns:WSStoredProcedurePK"/&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;

  &lt;xs:complexType name="existsStoredProcedureResponse"&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element minOccurs="0" name="return" type="tns:WSBoolean"/&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;

  &lt;xs:complexType name="putStoredProcedure"&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element minOccurs="0" name="arg0" type="tns:WSPutStoredProcedure"/&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;

  &lt;xs:complexType name="WSPutStoredProcedure"&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element minOccurs="0" name="wsStoredProcedure" type="tns:WSStoredProcedure"/&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;

  &lt;xs:complexType name="WSStoredProcedure"&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element minOccurs="0" name="description" type="xs:string"/&gt;
      &lt;xs:element minOccurs="0" name="name" type="xs:string"/&gt;
      &lt;xs:element minOccurs="0" name="procedure" type="xs:string"/&gt;
      &lt;xs:element minOccurs="0" name="refreshCache" type="xs:boolean"/&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;

  &lt;xs:complexType name="putStoredProcedureResponse"&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element minOccurs="0" name="return" type="tns:WSStoredProcedurePK"/&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;

  &lt;xs:complexType name="existsMenu"&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element minOccurs="0" name="arg0" type="tns:WSExistsMenu"/&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;

  &lt;xs:complexType name="WSExistsMenu"&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element minOccurs="0" name="wsMenuPK" type="tns:WSMenuPK"/&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;

  &lt;xs:complexType name="existsMenuResponse"&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element minOccurs="0" name="return" type="tns:WSBoolean"/&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;

  &lt;xs:complexType name="getComponentVersion"&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element minOccurs="0" name="arg0" type="tns:WSGetComponentVersion"/&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;

  &lt;xs:complexType name="WSGetComponentVersion"&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element minOccurs="0" name="component" type="tns:WSComponent"/&gt;
      &lt;xs:element minOccurs="0" name="id" type="xs:string"/&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;

  &lt;xs:complexType name="getComponentVersionResponse"&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element minOccurs="0" name="return" type="tns:WSVersion"/&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;

  &lt;xs:complexType name="WSVersion"&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element minOccurs="0" name="build" type="xs:string"/&gt;
      &lt;xs:element minOccurs="0" name="date" type="xs:string"/&gt;
      &lt;xs:element minOccurs="0" name="description" type="xs:string"/&gt;
      &lt;xs:element name="major" type="xs:int"/&gt;
      &lt;xs:element name="minor" type="xs:int"/&gt;
      &lt;xs:element name="revision" type="xs:int"/&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;

  &lt;xs:complexType name="putDBDataCluster"&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element minOccurs="0" name="arg0" type="tns:WSPutDBDataCluster"/&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;

  &lt;xs:complexType name="WSPutDBDataCluster"&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element minOccurs="0" name="name" type="xs:string"/&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;

  &lt;xs:complexType name="putDBDataClusterResponse"&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element minOccurs="0" name="return" type="tns:WSBoolean"/&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;

  &lt;xs:complexType name="getBusinessConceptKey"&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element minOccurs="0" name="arg0" type="tns:WSGetBusinessConceptKey"/&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;

  &lt;xs:complexType name="WSGetBusinessConceptKey"&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element minOccurs="0" name="concept" type="xs:string"/&gt;
      &lt;xs:element minOccurs="0" name="wsDataModelPK" type="tns:WSDataModelPK"/&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;

  &lt;xs:complexType name="getBusinessConceptKeyResponse"&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element minOccurs="0" name="return" type="tns:WSConceptKey"/&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;

  &lt;xs:complexType name="WSConceptKey"&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element maxOccurs="unbounded" minOccurs="0" name="fields" nillable="true" type="xs:string"/&gt;
      &lt;xs:element minOccurs="0" name="selector" type="xs:string"/&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;

  &lt;xs:complexType name="getRoutingOrderV2SByCriteria"&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element minOccurs="0" name="arg0" type="tns:WSGetRoutingOrderV2SByCriteria"/&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;

  &lt;xs:complexType name="WSGetRoutingOrderV2SByCriteria"&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element minOccurs="0" name="wsSearchCriteria" type="tns:WSRoutingOrderV2SearchCriteria"/&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;

  &lt;xs:complexType name="WSRoutingOrderV2SearchCriteria"&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element minOccurs="0" name="anyFieldContains" type="xs:string"/&gt;
      &lt;xs:element minOccurs="0" name="itemPKConceptContains" type="xs:string"/&gt;
      &lt;xs:element minOccurs="0" name="itemPKIDFieldsContain" type="xs:string"/&gt;
      &lt;xs:element minOccurs="0" name="messageContain" type="xs:string"/&gt;
      &lt;xs:element minOccurs="0" name="nameContains" type="xs:string"/&gt;
      &lt;xs:element minOccurs="0" name="serviceJNDIContains" type="xs:string"/&gt;
      &lt;xs:element minOccurs="0" name="serviceParametersContain" type="xs:string"/&gt;
      &lt;xs:element minOccurs="0" name="status" type="tns:WSRoutingOrderV2Status"/&gt;
      &lt;xs:element name="timeCreatedMax" type="xs:long"/&gt;
      &lt;xs:element name="timeCreatedMin" type="xs:long"/&gt;
      &lt;xs:element name="timeLastRunCompletedMax" type="xs:long"/&gt;
      &lt;xs:element name="timeLastRunCompletedMin" type="xs:long"/&gt;
      &lt;xs:element name="timeLastRunStartedMax" type="xs:long"/&gt;
      &lt;xs:element name="timeLastRunStartedMin" type="xs:long"/&gt;
      &lt;xs:element name="timeScheduledMax" type="xs:long"/&gt;
      &lt;xs:element name="timeScheduledMin" type="xs:long"/&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;

  &lt;xs:complexType name="getRoutingOrderV2SByCriteriaResponse"&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element minOccurs="0" name="return" type="tns:WSRoutingOrderV2Array"/&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;

  &lt;xs:complexType name="WSRoutingOrderV2Array"&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element maxOccurs="unbounded" minOccurs="0" name="wsRoutingOrder" nillable="true" type="tns:WSRoutingOrderV2"/&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;

  &lt;xs:complexType name="WSRoutingOrderV2"&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element minOccurs="0" name="bindingUniverseName" type="xs:string"/&gt;
      &lt;xs:element minOccurs="0" name="bindingUserToken" type="xs:string"/&gt;
      &lt;xs:element minOccurs="0" name="message" type="xs:string"/&gt;
      &lt;xs:element minOccurs="0" name="name" type="xs:string"/&gt;
      &lt;xs:element minOccurs="0" name="serviceJNDI" type="xs:string"/&gt;
      &lt;xs:element minOccurs="0" name="serviceParameters" type="xs:string"/&gt;
      &lt;xs:element minOccurs="0" name="status" type="tns:WSRoutingOrderV2Status"/&gt;
      &lt;xs:element name="timeCreated" type="xs:long"/&gt;
      &lt;xs:element name="timeLastRunCompleted" type="xs:long"/&gt;
      &lt;xs:element name="timeLastRunStarted" type="xs:long"/&gt;
      &lt;xs:element name="timeScheduled" type="xs:long"/&gt;
      &lt;xs:element minOccurs="0" name="wsItemPK" type="tns:WSItemPK"/&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;

  &lt;xs:complexType name="deleteMenu"&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element minOccurs="0" name="arg0" type="tns:WSDeleteMenu"/&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;

  &lt;xs:complexType name="WSDeleteMenu"&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element minOccurs="0" name="wsMenuPK" type="tns:WSMenuPK"/&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;

  &lt;xs:complexType name="deleteMenuResponse"&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element minOccurs="0" name="return" type="tns:WSMenuPK"/&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;

  &lt;xs:complexType name="getBackgroundJob"&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element minOccurs="0" name="arg0" type="tns:WSGetBackgroundJob"/&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;

  &lt;xs:complexType name="WSGetBackgroundJob"&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element minOccurs="0" name="pk" type="xs:string"/&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;

  &lt;xs:complexType name="getBackgroundJobResponse"&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element minOccurs="0" name="return" type="tns:WSBackgroundJob"/&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;

  &lt;xs:complexType name="WSBackgroundJob"&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element minOccurs="0" name="description" type="xs:string"/&gt;
      &lt;xs:element minOccurs="0" name="id" type="xs:string"/&gt;
      &lt;xs:element minOccurs="0" name="message" type="xs:string"/&gt;
      &lt;xs:element minOccurs="0" name="percentage" type="xs:int"/&gt;
      &lt;xs:element minOccurs="0" name="pipeline" type="tns:WSPipeline"/&gt;
      &lt;xs:element minOccurs="0" name="serializedObject" type="xs:base64Binary"/&gt;
      &lt;xs:element minOccurs="0" name="status" type="tns:BackgroundJobStatusType"/&gt;
      &lt;xs:element minOccurs="0" name="timestamp" type="xs:string"/&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;

  &lt;xs:complexType name="putItemWithCustomReport"&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element minOccurs="0" name="arg0" type="tns:WSPutItemWithCustomReport"/&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;

  &lt;xs:complexType name="WSPutItemWithCustomReport"&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element minOccurs="0" name="user" type="xs:string"/&gt;
      &lt;xs:element minOccurs="0" name="wsPutItemWithReport" type="tns:WSPutItemWithReport"/&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;

  &lt;xs:complexType name="putItemWithCustomReportResponse"&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element minOccurs="0" name="return" type="tns:WSItemPK"/&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;

  &lt;xs:complexType name="getServiceDocument"&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element minOccurs="0" name="arg0" type="tns:WSString"/&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;

  &lt;xs:complexType name="getServiceDocumentResponse"&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element minOccurs="0" name="return" type="tns:WSServiceGetDocument"/&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;

  &lt;xs:complexType name="WSServiceGetDocument"&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element minOccurs="0" name="configure" type="xs:string"/&gt;
      &lt;xs:element minOccurs="0" name="configureSchema" type="xs:string"/&gt;
      &lt;xs:element minOccurs="0" name="defaultConfig" type="xs:string"/&gt;
      &lt;xs:element minOccurs="0" name="description" type="xs:string"/&gt;
      &lt;xs:element minOccurs="0" name="document" type="xs:string"/&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;

  &lt;xs:complexType name="isItemModifiedByOther"&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element minOccurs="0" name="arg0" type="tns:WSIsItemModifiedByOther"/&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;

  &lt;xs:complexType name="WSIsItemModifiedByOther"&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element minOccurs="0" name="wsItem" type="tns:WSItem"/&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;

  &lt;xs:complexType name="WSItem"&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element minOccurs="0" name="conceptName" type="xs:string"/&gt;
      &lt;xs:element minOccurs="0" name="content" type="xs:string"/&gt;
      &lt;xs:element minOccurs="0" name="dataModelName" type="xs:string"/&gt;
      &lt;xs:element maxOccurs="unbounded" minOccurs="0" name="ids" nillable="true" type="xs:string"/&gt;
      &lt;xs:element name="insertionTime" type="xs:long"/&gt;
      &lt;xs:element minOccurs="0" name="taskId" type="xs:string"/&gt;
      &lt;xs:element minOccurs="0" name="wsDataClusterPK" type="tns:WSDataClusterPK"/&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;

  &lt;xs:complexType name="isItemModifiedByOtherResponse"&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element minOccurs="0" name="return" type="tns:WSBoolean"/&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;

  &lt;xs:complexType name="getRoutingRule"&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element minOccurs="0" name="arg0" type="tns:WSGetRoutingRule"/&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;

  &lt;xs:complexType name="WSGetRoutingRule"&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element minOccurs="0" name="wsRoutingRulePK" type="tns:WSRoutingRulePK"/&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;

  &lt;xs:complexType name="WSRoutingRulePK"&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element minOccurs="0" name="pk" type="xs:string"/&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;

  &lt;xs:complexType name="getRoutingRuleResponse"&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element minOccurs="0" name="return" type="tns:WSRoutingRule"/&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;

  &lt;xs:complexType name="WSRoutingRule"&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element minOccurs="0" name="concept" type="xs:string"/&gt;
      &lt;xs:element minOccurs="0" name="condition" type="xs:string"/&gt;
      &lt;xs:element minOccurs="0" name="deactive" type="xs:boolean"/&gt;
      &lt;xs:element minOccurs="0" name="description" type="xs:string"/&gt;
      &lt;xs:element name="executeOrder" type="xs:int"/&gt;
      &lt;xs:element minOccurs="0" name="name" type="xs:string"/&gt;
      &lt;xs:element minOccurs="0" name="parameters" type="xs:string"/&gt;
      &lt;xs:element minOccurs="0" name="serviceJNDI" type="xs:string"/&gt;
      &lt;xs:element name="synchronous" type="xs:boolean"/&gt;
      &lt;xs:element maxOccurs="unbounded" minOccurs="0" name="wsRoutingRuleExpressions" nillable="true" type="tns:WSRoutingRuleExpression"/&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;

  &lt;xs:complexType name="WSRoutingRuleExpression"&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element minOccurs="0" name="name" type="xs:string"/&gt;
      &lt;xs:element minOccurs="0" name="value" type="xs:string"/&gt;
      &lt;xs:element minOccurs="0" name="wsOperator" type="tns:WSRoutingRuleOperator"/&gt;
      &lt;xs:element minOccurs="0" name="xpath" type="xs:string"/&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;

  &lt;xs:complexType name="deleteRole"&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element minOccurs="0" name="arg0" type="tns:WSDeleteRole"/&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;

  &lt;xs:complexType name="WSDeleteRole"&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element minOccurs="0" name="wsRolePK" type="tns:WSRolePK"/&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;

  &lt;xs:complexType name="WSRolePK"&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element minOccurs="0" name="pk" type="xs:string"/&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;

  &lt;xs:complexType name="deleteRoleResponse"&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element minOccurs="0" name="return" type="tns:WSRolePK"/&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;

  &lt;xs:complexType name="putItem"&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element minOccurs="0" name="arg0" type="tns:WSPutItem"/&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;

  &lt;xs:complexType name="putItemResponse"&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element minOccurs="0" name="return" type="tns:WSItemPK"/&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;

  &lt;xs:complexType name="getItemsSort"&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element minOccurs="0" name="arg0" type="tns:WSGetItemsSort"/&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;

  &lt;xs:complexType name="WSGetItemsSort"&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element minOccurs="0" name="conceptName" type="xs:string"/&gt;
      &lt;xs:element minOccurs="0" name="dir" type="xs:string"/&gt;
      &lt;xs:element name="maxItems" type="xs:int"/&gt;
      &lt;xs:element name="skip" type="xs:int"/&gt;
      &lt;xs:element minOccurs="0" name="sort" type="xs:string"/&gt;
      &lt;xs:element name="spellTreshold" type="xs:int"/&gt;
      &lt;xs:element minOccurs="0" name="totalCountOnFirstResult" type="xs:boolean"/&gt;
      &lt;xs:element minOccurs="0" name="whereItem" type="tns:WSWhereItem"/&gt;
      &lt;xs:element minOccurs="0" name="wsDataClusterPK" type="tns:WSDataClusterPK"/&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;

  &lt;xs:complexType name="getItemsSortResponse"&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element minOccurs="0" name="return" type="tns:WSStringArray"/&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;

  &lt;xs:complexType name="getDataCluster"&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element minOccurs="0" name="arg0" type="tns:WSGetDataCluster"/&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;

  &lt;xs:complexType name="WSGetDataCluster"&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element minOccurs="0" name="wsDataClusterPK" type="tns:WSDataClusterPK"/&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;

  &lt;xs:complexType name="getDataClusterResponse"&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element minOccurs="0" name="return" type="tns:WSDataCluster"/&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;

  &lt;xs:complexType name="WSDataCluster"&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element minOccurs="0" name="description" type="xs:string"/&gt;
      &lt;xs:element minOccurs="0" name="name" type="xs:string"/&gt;
      &lt;xs:element minOccurs="0" name="vocabulary" type="xs:string"/&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;

  &lt;xs:complexType name="existsRole"&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element minOccurs="0" name="arg0" type="tns:WSExistsRole"/&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;

  &lt;xs:complexType name="WSExistsRole"&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element minOccurs="0" name="wsRolePK" type="tns:WSRolePK"/&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;

  &lt;xs:complexType name="existsRoleResponse"&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element minOccurs="0" name="return" type="tns:WSBoolean"/&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;

  &lt;xs:complexType name="getDigest"&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element minOccurs="0" name="arg0" type="tns:WSDigestKey"/&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;

  &lt;xs:complexType name="WSDigestKey"&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element minOccurs="0" name="objectName" type="xs:string"/&gt;
      &lt;xs:element minOccurs="0" name="type" type="xs:string"/&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;

  &lt;xs:complexType name="getDigestResponse"&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element minOccurs="0" name="return" type="tns:WSDigest"/&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;

  &lt;xs:complexType name="WSDigest"&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element minOccurs="0" name="digestValue" type="xs:string"/&gt;
      &lt;xs:element name="timeStamp" type="xs:long"/&gt;
      &lt;xs:element minOccurs="0" name="wsDigestKey" type="tns:WSDigestKey"/&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;

  &lt;xs:complexType name="getRoutingRulePKs"&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element minOccurs="0" name="arg0" type="tns:WSGetRoutingRulePKs"/&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;

  &lt;xs:complexType name="WSGetRoutingRulePKs"&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element minOccurs="0" name="regex" type="xs:string"/&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;

  &lt;xs:complexType name="getRoutingRulePKsResponse"&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element minOccurs="0" name="return" type="tns:WSRoutingRulePKArray"/&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;

  &lt;xs:complexType name="WSRoutingRulePKArray"&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element maxOccurs="unbounded" minOccurs="0" name="wsRoutingRulePKs" nillable="true" type="tns:WSRoutingRulePK"/&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;

  &lt;xs:complexType name="updateItemMetadata"&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element minOccurs="0" name="arg0" type="tns:WSUpdateMetadataItem"/&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;

  &lt;xs:complexType name="WSUpdateMetadataItem"&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element minOccurs="0" name="taskId" type="xs:string"/&gt;
      &lt;xs:element minOccurs="0" name="wsItemPK" type="tns:WSItemPK"/&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;

  &lt;xs:complexType name="updateItemMetadataResponse"&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element minOccurs="0" name="return" type="tns:WSItemPK"/&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;

  &lt;xs:complexType name="getBusinessConcepts"&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element minOccurs="0" name="arg0" type="tns:WSGetBusinessConcepts"/&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;

  &lt;xs:complexType name="WSGetBusinessConcepts"&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element minOccurs="0" name="wsDataModelPK" type="tns:WSDataModelPK"/&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;

  &lt;xs:complexType name="getBusinessConceptsResponse"&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element minOccurs="0" name="return" type="tns:WSStringArray"/&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;

  &lt;xs:complexType name="quickSearch"&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element minOccurs="0" name="arg0" type="tns:WSQuickSearch"/&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;

  &lt;xs:complexType name="WSQuickSearch"&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element minOccurs="0" name="direction" type="xs:string"/&gt;
      &lt;xs:element name="matchAllWords" type="xs:boolean"/&gt;
      &lt;xs:element name="maxItems" type="xs:int"/&gt;
      &lt;xs:element minOccurs="0" name="orderBy" type="xs:string"/&gt;
      &lt;xs:element minOccurs="0" name="searchedValue" type="xs:string"/&gt;
      &lt;xs:element name="skip" type="xs:int"/&gt;
      &lt;xs:element name="spellTreshold" type="xs:int"/&gt;
      &lt;xs:element minOccurs="0" name="wsDataClusterPK" type="tns:WSDataClusterPK"/&gt;
      &lt;xs:element minOccurs="0" name="wsViewPK" type="tns:WSViewPK"/&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;

  &lt;xs:complexType name="quickSearchResponse"&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element minOccurs="0" name="return" type="tns:WSStringArray"/&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;

  &lt;xs:complexType name="processBytesUsingTransformerAsBackgroundJob"&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element minOccurs="0" name="arg0" type="tns:WSProcessBytesUsingTransformerAsBackgroundJob"/&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;

  &lt;xs:complexType name="WSProcessBytesUsingTransformerAsBackgroundJob"&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element minOccurs="0" name="contentType" type="xs:string"/&gt;
      &lt;xs:element minOccurs="0" name="wsBytes" type="tns:WSByteArray"/&gt;
      &lt;xs:element minOccurs="0" name="wsOutputDecisionTable" type="tns:WSOutputDecisionTable"/&gt;
      &lt;xs:element minOccurs="0" name="wsTransformerPK" type="tns:WSTransformerPK"/&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;

  &lt;xs:complexType name="processBytesUsingTransformerAsBackgroundJobResponse"&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element minOccurs="0" name="return" type="tns:WSBackgroundJobPK"/&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;

  &lt;xs:complexType name="getStoredProcedurePKs"&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element minOccurs="0" name="arg0" type="tns:WSRegexStoredProcedure"/&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;

  &lt;xs:complexType name="WSRegexStoredProcedure"&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element minOccurs="0" name="regex" type="xs:string"/&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;

  &lt;xs:complexType name="getStoredProcedurePKsResponse"&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element minOccurs="0" name="return" type="tns:WSStoredProcedurePKArray"/&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;

  &lt;xs:complexType name="WSStoredProcedurePKArray"&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element maxOccurs="unbounded" minOccurs="0" name="wsStoredProcedurePK" nillable="true" type="tns:WSStoredProcedurePK"/&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;

  &lt;xs:complexType name="putTransformer"&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element minOccurs="0" name="arg0" type="tns:WSPutTransformer"/&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;

  &lt;xs:complexType name="WSPutTransformer"&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element minOccurs="0" name="wsTransformer" type="tns:WSTransformer"/&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;

  &lt;xs:complexType name="WSTransformer"&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element minOccurs="0" name="description" type="xs:string"/&gt;
      &lt;xs:element minOccurs="0" name="name" type="xs:string"/&gt;
      &lt;xs:element maxOccurs="unbounded" minOccurs="0" name="pluginSpecs" nillable="true" type="tns:WSTransformerPluginSpec"/&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;

  &lt;xs:complexType name="WSTransformerPluginSpec"&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element minOccurs="0" name="description" type="xs:string"/&gt;
      &lt;xs:element minOccurs="0" name="input" type="xs:string"/&gt;
      &lt;xs:element minOccurs="0" name="output" type="xs:string"/&gt;
      &lt;xs:element minOccurs="0" name="parameters" type="xs:string"/&gt;
      &lt;xs:element minOccurs="0" name="pluginJNDI" type="xs:string"/&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;

  &lt;xs:complexType name="putTransformerResponse"&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element minOccurs="0" name="return" type="tns:WSTransformerPK"/&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;

  &lt;xs:complexType name="countItemsByCustomFKFilters"&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element minOccurs="0" name="arg0" type="tns:WSCountItemsByCustomFKFilters"/&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;

  &lt;xs:complexType name="WSCountItemsByCustomFKFilters"&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element minOccurs="0" name="conceptName" type="xs:string"/&gt;
      &lt;xs:element minOccurs="0" name="injectedXpath" type="xs:string"/&gt;
      &lt;xs:element minOccurs="0" name="wsDataClusterPK" type="tns:WSDataClusterPK"/&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;

  &lt;xs:complexType name="countItemsByCustomFKFiltersResponse"&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element minOccurs="0" name="return" type="tns:WSString"/&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;

  &lt;xs:complexType name="updateDigest"&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element minOccurs="0" name="arg0" type="tns:WSDigest"/&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;

  &lt;xs:complexType name="updateDigestResponse"&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element minOccurs="0" name="return" type="tns:WSLong"/&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;

  &lt;xs:complexType name="WSLong"&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element name="value" type="xs:long"/&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;

  &lt;xs:complexType name="getConceptsInDataCluster"&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element minOccurs="0" name="arg0" type="tns:WSGetConceptsInDataCluster"/&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;

  &lt;xs:complexType name="WSGetConceptsInDataCluster"&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element minOccurs="0" name="wsDataClusterPK" type="tns:WSDataClusterPK"/&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;

  &lt;xs:complexType name="getConceptsInDataClusterResponse"&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element minOccurs="0" name="return" type="tns:WSStringArray"/&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;

  &lt;xs:complexType name="processFileUsingTransformerAsBackgroundJob"&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element minOccurs="0" name="arg0" type="tns:WSProcessFileUsingTransformerAsBackgroundJob"/&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;

  &lt;xs:complexType name="WSProcessFileUsingTransformerAsBackgroundJob"&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element minOccurs="0" name="contentType" type="xs:string"/&gt;
      &lt;xs:element minOccurs="0" name="fileName" type="xs:string"/&gt;
      &lt;xs:element minOccurs="0" name="wsOutputDecisionTable" type="tns:WSOutputDecisionTable"/&gt;
      &lt;xs:element minOccurs="0" name="wsTransformerPK" type="tns:WSTransformerPK"/&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;

  &lt;xs:complexType name="processFileUsingTransformerAsBackgroundJobResponse"&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element minOccurs="0" name="return" type="tns:WSBackgroundJobPK"/&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;

  &lt;xs:complexType name="existsTransformer"&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element minOccurs="0" name="arg0" type="tns:WSExistsTransformer"/&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;

  &lt;xs:complexType name="WSExistsTransformer"&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element minOccurs="0" name="wsTransformerPK" type="tns:WSTransformerPK"/&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;

  &lt;xs:complexType name="existsTransformerResponse"&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element minOccurs="0" name="return" type="tns:WSBoolean"/&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;

  &lt;xs:complexType name="getDataModel"&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element minOccurs="0" name="arg0" type="tns:WSGetDataModel"/&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;

  &lt;xs:complexType name="WSGetDataModel"&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element minOccurs="0" name="wsDataModelPK" type="tns:WSDataModelPK"/&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;

  &lt;xs:complexType name="getDataModelResponse"&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element minOccurs="0" name="return" type="tns:WSDataModel"/&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;

  &lt;xs:complexType name="WSDataModel"&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element minOccurs="0" name="description" type="xs:string"/&gt;
      &lt;xs:element minOccurs="0" name="name" type="xs:string"/&gt;
      &lt;xs:element minOccurs="0" name="xsdSchema" type="xs:string"/&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;

  &lt;xs:complexType name="runQuery"&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element minOccurs="0" name="arg0" type="tns:WSRunQuery"/&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;

  &lt;xs:complexType name="WSRunQuery"&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element maxOccurs="unbounded" minOccurs="0" name="parameters" nillable="true" type="xs:string"/&gt;
      &lt;xs:element minOccurs="0" name="query" type="xs:string"/&gt;
      &lt;xs:element minOccurs="0" name="wsDataClusterPK" type="tns:WSDataClusterPK"/&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;

  &lt;xs:complexType name="runQueryResponse"&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element minOccurs="0" name="return" type="tns:WSStringArray"/&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;

  &lt;xs:complexType name="putBusinessConcept"&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element minOccurs="0" name="arg0" type="tns:WSPutBusinessConcept"/&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;

  &lt;xs:complexType name="WSPutBusinessConcept"&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element minOccurs="0" name="businessConcept" type="tns:WSBusinessConcept"/&gt;
      &lt;xs:element minOccurs="0" name="wsDataModelPK" type="tns:WSDataModelPK"/&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;

  &lt;xs:complexType name="WSBusinessConcept"&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element minOccurs="0" name="businessTemplate" type="xs:string"/&gt;
      &lt;xs:element minOccurs="0" name="name" type="xs:string"/&gt;
      &lt;xs:element maxOccurs="unbounded" minOccurs="0" name="wsDescription" nillable="true" type="tns:WSI18NString"/&gt;
      &lt;xs:element maxOccurs="unbounded" minOccurs="0" name="wsLabel" nillable="true" type="tns:WSI18NString"/&gt;
      &lt;xs:element minOccurs="0" name="wsUniqueKey" type="tns:WSKey"/&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;

  &lt;xs:complexType name="WSI18NString"&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element minOccurs="0" name="label" type="xs:string"/&gt;
      &lt;xs:element minOccurs="0" name="language" type="tns:WSLanguage"/&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;

  &lt;xs:complexType name="WSKey"&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element maxOccurs="unbounded" minOccurs="0" name="fieldpath" nillable="true" type="xs:string"/&gt;
      &lt;xs:element minOccurs="0" name="selectorpath" type="xs:string"/&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;

  &lt;xs:complexType name="putBusinessConceptResponse"&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element minOccurs="0" name="return" type="tns:WSString"/&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;

  &lt;xs:complexType name="logout"&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element minOccurs="0" name="arg0" type="tns:WSLogout"/&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;

  &lt;xs:complexType name="WSLogout"&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element minOccurs="0" name="dummy" type="xs:string"/&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;

  &lt;xs:complexType name="logoutResponse"&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element minOccurs="0" name="return" type="tns:WSString"/&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;

  &lt;xs:complexType name="existsView"&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element minOccurs="0" name="arg0" type="tns:WSExistsView"/&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;

  &lt;xs:complexType name="WSExistsView"&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element minOccurs="0" name="wsViewPK" type="tns:WSViewPK"/&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;

  &lt;xs:complexType name="existsViewResponse"&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element minOccurs="0" name="return" type="tns:WSBoolean"/&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;

  &lt;xs:complexType name="serviceAction"&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element minOccurs="0" name="arg0" type="tns:WSServiceAction"/&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;

  &lt;xs:complexType name="WSServiceAction"&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element minOccurs="0" name="jndiName" type="xs:string"/&gt;
      &lt;xs:element minOccurs="0" name="methodName" type="xs:string"/&gt;
      &lt;xs:element maxOccurs="unbounded" minOccurs="0" name="methodParameters" nillable="true" type="xs:string"/&gt;
      &lt;xs:element minOccurs="0" name="wsAction" type="tns:WSServiceActionCode"/&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;

  &lt;xs:complexType name="serviceActionResponse"&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element minOccurs="0" name="return" type="tns:WSString"/&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;

  &lt;xs:complexType name="getViewPKs"&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element minOccurs="0" name="arg0" type="tns:WSGetViewPKs"/&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;

  &lt;xs:complexType name="WSGetViewPKs"&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element minOccurs="0" name="regex" type="xs:string"/&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;

  &lt;xs:complexType name="getViewPKsResponse"&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element minOccurs="0" name="return" type="tns:WSViewPKArray"/&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;

  &lt;xs:complexType name="WSViewPKArray"&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element maxOccurs="unbounded" minOccurs="0" name="wsViewPK" nillable="true" type="tns:WSViewPK"/&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;

  &lt;xs:complexType name="executeStoredProcedure"&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element minOccurs="0" name="arg0" type="tns:WSExecuteStoredProcedure"/&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;

  &lt;xs:complexType name="WSExecuteStoredProcedure"&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element maxOccurs="unbounded" minOccurs="0" name="parameters" nillable="true" type="xs:string"/&gt;
      &lt;xs:element minOccurs="0" name="wsDataClusterPK" type="tns:WSDataClusterPK"/&gt;
      &lt;xs:element minOccurs="0" name="wsStoredProcedurePK" type="tns:WSStoredProcedurePK"/&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;

  &lt;xs:complexType name="executeStoredProcedureResponse"&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element minOccurs="0" name="return" type="tns:WSStringArray"/&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;

  &lt;xs:complexType name="deleteItemWithReport"&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element minOccurs="0" name="arg0" type="tns:WSDeleteItemWithReport"/&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;

  &lt;xs:complexType name="WSDeleteItemWithReport"&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element minOccurs="0" name="invokeBeforeSaving" type="xs:boolean"/&gt;
      &lt;xs:element minOccurs="0" name="operateType" type="xs:string"/&gt;
      &lt;xs:element minOccurs="0" name="override" type="xs:boolean"/&gt;
      &lt;xs:element minOccurs="0" name="pushToUpdateReport" type="xs:boolean"/&gt;
      &lt;xs:element minOccurs="0" name="source" type="xs:string"/&gt;
      &lt;xs:element minOccurs="0" name="updatePath" type="xs:string"/&gt;
      &lt;xs:element minOccurs="0" name="user" type="xs:string"/&gt;
      &lt;xs:element minOccurs="0" name="wsItemPK" type="tns:WSItemPK"/&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;

  &lt;xs:complexType name="deleteItemWithReportResponse"&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element minOccurs="0" name="return" type="tns:WSString"/&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;

  &lt;xs:complexType name="initMDM"&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element minOccurs="0" name="arg0" type="tns:WSInitData"/&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;

  &lt;xs:complexType name="WSInitData"&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element minOccurs="0" name="xmlSchema" type="xs:string"/&gt;
      &lt;xs:element name="zap" type="xs:boolean"/&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;

  &lt;xs:complexType name="initMDMResponse"&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element minOccurs="0" name="return" type="tns:WSInt"/&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;

  &lt;xs:complexType name="deleteRoutingOrderV2"&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element minOccurs="0" name="arg0" type="tns:WSDeleteRoutingOrderV2"/&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;

  &lt;xs:complexType name="WSDeleteRoutingOrderV2"&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element minOccurs="0" name="wsRoutingOrderPK" type="tns:WSRoutingOrderV2PK"/&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;

  &lt;xs:complexType name="deleteRoutingOrderV2Response"&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element minOccurs="0" name="return" type="tns:WSRoutingOrderV2PK"/&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;

  &lt;xs:complexType name="getStoredProcedure"&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element minOccurs="0" name="arg0" type="tns:WSGetStoredProcedure"/&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;

  &lt;xs:complexType name="WSGetStoredProcedure"&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element minOccurs="0" name="wsStoredProcedurePK" type="tns:WSStoredProcedurePK"/&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;

  &lt;xs:complexType name="getStoredProcedureResponse"&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element minOccurs="0" name="return" type="tns:WSStoredProcedure"/&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;

  &lt;xs:complexType name="getItemPKsByCriteria"&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element minOccurs="0" name="arg0" type="tns:WSGetItemPKsByCriteria"/&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;

  &lt;xs:complexType name="WSGetItemPKsByCriteria"&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element minOccurs="0" name="conceptName" type="xs:string"/&gt;
      &lt;xs:element minOccurs="0" name="contentKeywords" type="xs:string"/&gt;
      &lt;xs:element minOccurs="0" name="fromDate" type="xs:long"/&gt;
      &lt;xs:element minOccurs="0" name="keys" type="xs:string"/&gt;
      &lt;xs:element minOccurs="0" name="keysKeywords" type="xs:string"/&gt;
      &lt;xs:element name="maxItems" type="xs:int"/&gt;
      &lt;xs:element name="skip" type="xs:int"/&gt;
      &lt;xs:element minOccurs="0" name="toDate" type="xs:long"/&gt;
      &lt;xs:element minOccurs="0" name="wsDataClusterPK" type="tns:WSDataClusterPK"/&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;

  &lt;xs:complexType name="getItemPKsByCriteriaResponse"&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element minOccurs="0" name="return" type="tns:WSItemPKsByCriteriaResponse"/&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;

  &lt;xs:complexType name="WSItemPKsByCriteriaResponse"&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element maxOccurs="unbounded" minOccurs="0" name="results" nillable="true" type="tns:WSItemPKsByCriteriaResponseResults"/&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;

  &lt;xs:complexType name="WSItemPKsByCriteriaResponseResults"&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element name="date" type="xs:long"/&gt;
      &lt;xs:element minOccurs="0" name="taskId" type="xs:string"/&gt;
      &lt;xs:element minOccurs="0" name="wsItemPK" type="tns:WSItemPK"/&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;

  &lt;xs:complexType name="getDataClusterPKs"&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element minOccurs="0" name="arg0" type="tns:WSRegexDataClusterPKs"/&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;

  &lt;xs:complexType name="WSRegexDataClusterPKs"&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element minOccurs="0" name="regex" type="xs:string"/&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;

  &lt;xs:complexType name="getDataClusterPKsResponse"&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element minOccurs="0" name="return" type="tns:WSDataClusterPKArray"/&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;

  &lt;xs:complexType name="WSDataClusterPKArray"&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element maxOccurs="unbounded" minOccurs="0" name="wsDataClusterPKs" nillable="true" type="tns:WSDataClusterPK"/&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;

  &lt;xs:complexType name="getTransformer"&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element minOccurs="0" name="arg0" type="tns:WSGetTransformer"/&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;

  &lt;xs:complexType name="WSGetTransformer"&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element minOccurs="0" name="wsTransformerPK" type="tns:WSTransformerPK"/&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;

  &lt;xs:complexType name="getTransformerResponse"&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element minOccurs="0" name="return" type="tns:WSTransformer"/&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;

  &lt;xs:complexType name="getTransformerPluginV2Details"&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element minOccurs="0" name="arg0" type="tns:WSGetTransformerPluginV2Details"/&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;

  &lt;xs:complexType name="WSGetTransformerPluginV2Details"&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element minOccurs="0" name="jndiName" type="xs:string"/&gt;
      &lt;xs:element minOccurs="0" name="language" type="xs:string"/&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;

  &lt;xs:complexType name="getTransformerPluginV2DetailsResponse"&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element minOccurs="0" name="return" type="tns:WSTransformerPluginV2Details"/&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;

  &lt;xs:complexType name="WSTransformerPluginV2Details"&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element minOccurs="0" name="description" type="xs:string"/&gt;
      &lt;xs:element minOccurs="0" name="documentation" type="xs:string"/&gt;
      &lt;xs:element maxOccurs="unbounded" minOccurs="0" name="inputVariableDescriptors" nillable="true" type="tns:WSTransformerPluginV2VariableDescriptor"/&gt;
      &lt;xs:element maxOccurs="unbounded" minOccurs="0" name="outputVariableDescriptors" nillable="true" type="tns:WSTransformerPluginV2VariableDescriptor"/&gt;
      &lt;xs:element minOccurs="0" name="parametersSchema" type="xs:string"/&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;

  &lt;xs:complexType name="WSTransformerPluginV2VariableDescriptor"&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element maxOccurs="unbounded" minOccurs="0" name="contentTypesRegex" nillable="true" type="xs:string"/&gt;
      &lt;xs:element minOccurs="0" name="description" type="xs:string"/&gt;
      &lt;xs:element name="mandatory" type="xs:boolean"/&gt;
      &lt;xs:element maxOccurs="unbounded" minOccurs="0" name="possibleValuesRegex" nillable="true" type="xs:string"/&gt;
      &lt;xs:element minOccurs="0" name="variableName" type="xs:string"/&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;

  &lt;xs:complexType name="putServiceConfiguration"&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element minOccurs="0" name="arg0" type="tns:WSServicePutConfiguration"/&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;

  &lt;xs:complexType name="WSServicePutConfiguration"&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element minOccurs="0" name="configuration" type="xs:string"/&gt;
      &lt;xs:element minOccurs="0" name="jndiName" type="xs:string"/&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;

  &lt;xs:complexType name="putServiceConfigurationResponse"&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element minOccurs="0" name="return" type="tns:WSString"/&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;

  &lt;xs:complexType name="getItemPKsByFullCriteria"&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element minOccurs="0" name="arg0" type="tns:WSGetItemPKsByFullCriteria"/&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;

  &lt;xs:complexType name="WSGetItemPKsByFullCriteria"&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element name="useFTSearch" type="xs:boolean"/&gt;
      &lt;xs:element minOccurs="0" name="wsGetItemPKsByCriteria" type="tns:WSGetItemPKsByCriteria"/&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;

  &lt;xs:complexType name="getItemPKsByFullCriteriaResponse"&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element minOccurs="0" name="return" type="tns:WSItemPKsByCriteriaResponse"/&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;

  &lt;xs:complexType name="processFileUsingTransformer"&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element minOccurs="0" name="arg0" type="tns:WSProcessFileUsingTransformer"/&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;

  &lt;xs:complexType name="WSProcessFileUsingTransformer"&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element minOccurs="0" name="contentType" type="xs:string"/&gt;
      &lt;xs:element minOccurs="0" name="fileName" type="xs:string"/&gt;
      &lt;xs:element minOccurs="0" name="wsOutputDecisionTable" type="tns:WSOutputDecisionTable"/&gt;
      &lt;xs:element minOccurs="0" name="wsTransformerPK" type="tns:WSTransformerPK"/&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;

  &lt;xs:complexType name="processFileUsingTransformerResponse"&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element minOccurs="0" name="return" type="tns:WSPipeline"/&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;

  &lt;xs:complexType name="getFullPathValues"&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element minOccurs="0" name="arg0" type="tns:WSGetFullPathValues"/&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;

  &lt;xs:complexType name="WSGetFullPathValues"&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element minOccurs="0" name="direction" type="xs:string"/&gt;
      &lt;xs:element minOccurs="0" name="fullPath" type="xs:string"/&gt;
      &lt;xs:element minOccurs="0" name="orderBy" type="xs:string"/&gt;
      &lt;xs:element name="spellThreshold" type="xs:int"/&gt;
      &lt;xs:element minOccurs="0" name="whereItem" type="tns:WSWhereItem"/&gt;
      &lt;xs:element minOccurs="0" name="wsDataClusterPK" type="tns:WSDataClusterPK"/&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;

  &lt;xs:complexType name="getFullPathValuesResponse"&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element minOccurs="0" name="return" type="tns:WSStringArray"/&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;

  &lt;xs:complexType name="findAllDroppedItemsPKs"&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element minOccurs="0" name="arg0" type="tns:WSFindAllDroppedItemsPKs"/&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;

  &lt;xs:complexType name="WSFindAllDroppedItemsPKs"&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element minOccurs="0" name="regex" type="xs:string"/&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;

  &lt;xs:complexType name="findAllDroppedItemsPKsResponse"&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element minOccurs="0" name="return" type="tns:WSDroppedItemPKArray"/&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;

  &lt;xs:complexType name="WSDroppedItemPKArray"&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element maxOccurs="unbounded" minOccurs="0" name="wsDroppedItemPK" nillable="true" type="tns:WSDroppedItemPK"/&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;

  &lt;xs:complexType name="getMenuPKs"&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element minOccurs="0" name="arg0" type="tns:WSGetMenuPKs"/&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;

  &lt;xs:complexType name="WSGetMenuPKs"&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element minOccurs="0" name="regex" type="xs:string"/&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;

  &lt;xs:complexType name="getMenuPKsResponse"&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element minOccurs="0" name="return" type="tns:WSMenuPKArray"/&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;

  &lt;xs:complexType name="WSMenuPKArray"&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element maxOccurs="unbounded" minOccurs="0" name="wsMenuPK" nillable="true" type="tns:WSMenuPK"/&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;

  &lt;xs:complexType name="routeItemV2"&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element minOccurs="0" name="arg0" type="tns:WSRouteItemV2"/&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;

  &lt;xs:complexType name="WSRouteItemV2"&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element minOccurs="0" name="wsItemPK" type="tns:WSItemPK"/&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;

  &lt;xs:complexType name="routeItemV2Response"&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element minOccurs="0" name="return" type="tns:WSRoutingRulePKArray"/&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;

  &lt;xs:complexType name="ping"&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element minOccurs="0" name="arg0" type="tns:WSPing"/&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;

  &lt;xs:complexType name="WSPing"&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element minOccurs="0" name="echo" type="xs:string"/&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;

  &lt;xs:complexType name="pingResponse"&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element minOccurs="0" name="return" type="tns:WSString"/&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;

  &lt;xs:complexType name="getRoutingOrderV2PKsByCriteria"&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element minOccurs="0" name="arg0" type="tns:WSGetRoutingOrderV2PKsByCriteria"/&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;

  &lt;xs:complexType name="WSGetRoutingOrderV2PKsByCriteria"&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element minOccurs="0" name="wsSearchCriteria" type="tns:WSRoutingOrderV2SearchCriteria"/&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;

  &lt;xs:complexType name="getRoutingOrderV2PKsByCriteriaResponse"&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element minOccurs="0" name="return" type="tns:WSRoutingOrderV2PKArray"/&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;

  &lt;xs:complexType name="WSRoutingOrderV2PKArray"&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element maxOccurs="unbounded" minOccurs="0" name="wsRoutingOrder" nillable="true" type="tns:WSRoutingOrderV2PK"/&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;

  &lt;xs:complexType name="deleteTransformerV2"&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element minOccurs="0" name="arg0" type="tns:WSDeleteTransformerV2"/&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;

  &lt;xs:complexType name="WSDeleteTransformerV2"&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element minOccurs="0" name="wsTransformerV2PK" type="tns:WSTransformerV2PK"/&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;

  &lt;xs:complexType name="deleteTransformerV2Response"&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element minOccurs="0" name="return" type="tns:WSTransformerV2PK"/&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;

  &lt;xs:complexType name="putDataModel"&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element minOccurs="0" name="arg0" type="tns:WSPutDataModel"/&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;

  &lt;xs:complexType name="WSPutDataModel"&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element minOccurs="0" name="wsDataModel" type="tns:WSDataModel"/&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;

  &lt;xs:complexType name="putDataModelResponse"&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element minOccurs="0" name="return" type="tns:WSDataModelPK"/&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;

  &lt;xs:complexType name="getMDMCategory"&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element minOccurs="0" name="arg0" type="tns:WSCategoryData"/&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;

  &lt;xs:complexType name="WSCategoryData"&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element minOccurs="0" name="categorySchema" type="xs:string"/&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;

  &lt;xs:complexType name="getMDMCategoryResponse"&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element minOccurs="0" name="return" type="tns:WSCategoryData"/&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;

  &lt;xs:complexType name="checkServiceConfiguration"&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element minOccurs="0" name="arg0" type="tns:WSCheckServiceConfigRequest"/&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;

  &lt;xs:complexType name="WSCheckServiceConfigRequest"&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element minOccurs="0" name="conf" type="xs:string"/&gt;
      &lt;xs:element minOccurs="0" name="jndiName" type="xs:string"/&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;

  &lt;xs:complexType name="checkServiceConfigurationResponse"&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element minOccurs="0" name="return" type="tns:WSCheckServiceConfigResponse"/&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;

  &lt;xs:complexType name="WSCheckServiceConfigResponse"&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element minOccurs="0" name="checkResult" type="xs:boolean"/&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;

  &lt;xs:complexType name="getTransformerV2PKs"&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element minOccurs="0" name="arg0" type="tns:WSGetTransformerV2PKs"/&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;

  &lt;xs:complexType name="WSGetTransformerV2PKs"&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element minOccurs="0" name="regex" type="xs:string"/&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;

  &lt;xs:complexType name="getTransformerV2PKsResponse"&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element minOccurs="0" name="return" type="tns:WSTransformerV2PKArray"/&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;

  &lt;xs:complexType name="WSTransformerV2PKArray"&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element maxOccurs="unbounded" minOccurs="0" name="wsTransformerV2PK" nillable="true" type="tns:WSTransformerV2PK"/&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;

  &lt;xs:complexType name="putTransformerPluginV2Configuration"&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element minOccurs="0" name="arg0" type="tns:WSTransformerPluginV2PutConfiguration"/&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;

  &lt;xs:complexType name="WSTransformerPluginV2PutConfiguration"&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element minOccurs="0" name="configuration" type="xs:string"/&gt;
      &lt;xs:element minOccurs="0" name="jndiName" type="xs:string"/&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;

  &lt;xs:complexType name="putTransformerPluginV2ConfigurationResponse"&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element minOccurs="0" name="return" type="tns:WSString"/&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;

  &lt;xs:complexType name="getRole"&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element minOccurs="0" name="arg0" type="tns:WSGetRole"/&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;

  &lt;xs:complexType name="WSGetRole"&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element minOccurs="0" name="wsRolePK" type="tns:WSRolePK"/&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;

  &lt;xs:complexType name="getRoleResponse"&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element minOccurs="0" name="return" type="tns:WSRole"/&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;

  &lt;xs:complexType name="WSRole"&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element minOccurs="0" name="description" type="xs:string"/&gt;
      &lt;xs:element minOccurs="0" name="name" type="xs:string"/&gt;
      &lt;xs:element maxOccurs="unbounded" minOccurs="0" name="specification" nillable="true" type="tns:WSRoleSpecification"/&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;

  &lt;xs:complexType name="WSRoleSpecification"&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element name="admin" type="xs:boolean"/&gt;
      &lt;xs:element maxOccurs="unbounded" minOccurs="0" name="instance" nillable="true" type="tns:WSRoleSpecificationInstance"/&gt;
      &lt;xs:element minOccurs="0" name="objectType" type="xs:string"/&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;

  &lt;xs:complexType name="WSRoleSpecificationInstance"&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element minOccurs="0" name="instanceName" type="xs:string"/&gt;
      &lt;xs:element maxOccurs="unbounded" minOccurs="0" name="parameter" nillable="true" type="xs:string"/&gt;
      &lt;xs:element name="writable" type="xs:boolean"/&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;

  &lt;xs:complexType name="deleteView"&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element minOccurs="0" name="arg0" type="tns:WSDeleteView"/&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;

  &lt;xs:complexType name="WSDeleteView"&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element minOccurs="0" name="wsViewPK" type="tns:WSViewPK"/&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;

  &lt;xs:complexType name="deleteViewResponse"&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element minOccurs="0" name="return" type="tns:WSViewPK"/&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;

  &lt;xs:complexType name="deleteDataModel"&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element minOccurs="0" name="arg0" type="tns:WSDeleteDataModel"/&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;

  &lt;xs:complexType name="WSDeleteDataModel"&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element minOccurs="0" name="wsDataModelPK" type="tns:WSDataModelPK"/&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;

  &lt;xs:complexType name="deleteDataModelResponse"&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element minOccurs="0" name="return" type="tns:WSDataModelPK"/&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;

  &lt;xs:complexType name="putRole"&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element minOccurs="0" name="arg0" type="tns:WSPutRole"/&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;

  &lt;xs:complexType name="WSPutRole"&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element minOccurs="0" name="wsRole" type="tns:WSRole"/&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;

  &lt;xs:complexType name="putRoleResponse"&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element minOccurs="0" name="return" type="tns:WSRolePK"/&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;

  &lt;xs:complexType name="getRoutingOrderV2ByCriteriaWithPaging"&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element minOccurs="0" name="arg0" type="tns:WSGetRoutingOrderV2ByCriteriaWithPaging"/&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;

  &lt;xs:complexType name="WSGetRoutingOrderV2ByCriteriaWithPaging"&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element minOccurs="0" name="wsSearchCriteriaWithPaging" type="tns:WSRoutingOrderV2SearchCriteriaWithPaging"/&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;

  &lt;xs:complexType name="WSRoutingOrderV2SearchCriteriaWithPaging"&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element minOccurs="0" name="anyFieldContains" type="xs:string"/&gt;
      &lt;xs:element minOccurs="0" name="itemPKConceptContains" type="xs:string"/&gt;
      &lt;xs:element minOccurs="0" name="itemPKIDFieldsContain" type="xs:string"/&gt;
      &lt;xs:element name="maxItems" type="xs:int"/&gt;
      &lt;xs:element minOccurs="0" name="messageContain" type="xs:string"/&gt;
      &lt;xs:element minOccurs="0" name="nameContains" type="xs:string"/&gt;
      &lt;xs:element minOccurs="0" name="serviceJNDIContains" type="xs:string"/&gt;
      &lt;xs:element minOccurs="0" name="serviceParametersContain" type="xs:string"/&gt;
      &lt;xs:element name="skip" type="xs:int"/&gt;
      &lt;xs:element minOccurs="0" name="status" type="tns:WSRoutingOrderV2Status"/&gt;
      &lt;xs:element name="timeCreatedMax" type="xs:long"/&gt;
      &lt;xs:element name="timeCreatedMin" type="xs:long"/&gt;
      &lt;xs:element name="timeLastRunCompletedMax" type="xs:long"/&gt;
      &lt;xs:element name="timeLastRunCompletedMin" type="xs:long"/&gt;
      &lt;xs:element name="timeLastRunStartedMax" type="xs:long"/&gt;
      &lt;xs:element name="timeLastRunStartedMin" type="xs:long"/&gt;
      &lt;xs:element name="timeScheduledMax" type="xs:long"/&gt;
      &lt;xs:element name="timeScheduledMin" type="xs:long"/&gt;
      &lt;xs:element minOccurs="0" name="totalCountOnFirstResult" type="xs:boolean"/&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;

  &lt;xs:complexType name="getRoutingOrderV2ByCriteriaWithPagingResponse"&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element minOccurs="0" name="return" type="tns:WSRoutingOrderV2Array"/&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;

  &lt;xs:complexType name="getDataModelPKs"&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element minOccurs="0" name="arg0" type="tns:WSRegexDataModelPKs"/&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;

  &lt;xs:complexType name="WSRegexDataModelPKs"&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element minOccurs="0" name="regex" type="xs:string"/&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;

  &lt;xs:complexType name="getDataModelPKsResponse"&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element minOccurs="0" name="return" type="tns:WSDataModelPKArray"/&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;

  &lt;xs:complexType name="WSDataModelPKArray"&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element maxOccurs="unbounded" minOccurs="0" name="wsDataModelPKs" nillable="true" type="tns:WSDataModelPK"/&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;

  &lt;xs:complexType name="count"&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element minOccurs="0" name="arg0" type="tns:WSCount"/&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;

  &lt;xs:complexType name="WSCount"&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element minOccurs="0" name="countPath" type="xs:string"/&gt;
      &lt;xs:element name="spellTreshold" type="xs:int"/&gt;
      &lt;xs:element minOccurs="0" name="whereItem" type="tns:WSWhereItem"/&gt;
      &lt;xs:element minOccurs="0" name="wsDataClusterPK" type="tns:WSDataClusterPK"/&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;

  &lt;xs:complexType name="countResponse"&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element minOccurs="0" name="return" type="tns:WSString"/&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;

  &lt;xs:complexType name="existsDataCluster"&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element minOccurs="0" name="arg0" type="tns:WSExistsDataCluster"/&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;

  &lt;xs:complexType name="WSExistsDataCluster"&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element minOccurs="0" name="wsDataClusterPK" type="tns:WSDataClusterPK"/&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;

  &lt;xs:complexType name="existsDataClusterResponse"&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element minOccurs="0" name="return" type="tns:WSBoolean"/&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;

  &lt;xs:complexType name="recoverDroppedItem"&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element minOccurs="0" name="arg0" type="tns:WSRecoverDroppedItem"/&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;

  &lt;xs:complexType name="WSRecoverDroppedItem"&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element minOccurs="0" name="wsDroppedItemPK" type="tns:WSDroppedItemPK"/&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;

  &lt;xs:complexType name="recoverDroppedItemResponse"&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element minOccurs="0" name="return" type="tns:WSItemPK"/&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;

  &lt;xs:complexType name="loadDroppedItem"&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element minOccurs="0" name="arg0" type="tns:WSLoadDroppedItem"/&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;

  &lt;xs:complexType name="WSLoadDroppedItem"&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element minOccurs="0" name="wsDroppedItemPK" type="tns:WSDroppedItemPK"/&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;

  &lt;xs:complexType name="loadDroppedItemResponse"&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element minOccurs="0" name="return" type="tns:WSDroppedItem"/&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;

  &lt;xs:complexType name="WSDroppedItem"&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element minOccurs="0" name="conceptName" type="xs:string"/&gt;
      &lt;xs:element maxOccurs="unbounded" minOccurs="0" name="ids" nillable="true" type="xs:string"/&gt;
      &lt;xs:element minOccurs="0" name="insertionTime" type="xs:long"/&gt;
      &lt;xs:element minOccurs="0" name="insertionUserName" type="xs:string"/&gt;
      &lt;xs:element minOccurs="0" name="partPath" type="xs:string"/&gt;
      &lt;xs:element minOccurs="0" name="projection" type="xs:string"/&gt;
      &lt;xs:element minOccurs="0" name="uniqueId" type="xs:string"/&gt;
      &lt;xs:element minOccurs="0" name="wsDataClusterPK" type="tns:WSDataClusterPK"/&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;

  &lt;xs:complexType name="deleteRoutingRule"&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element minOccurs="0" name="arg0" type="tns:WSDeleteRoutingRule"/&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;

  &lt;xs:complexType name="WSDeleteRoutingRule"&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element minOccurs="0" name="wsRoutingRulePK" type="tns:WSRoutingRulePK"/&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;

  &lt;xs:complexType name="deleteRoutingRuleResponse"&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element minOccurs="0" name="return" type="tns:WSRoutingRulePK"/&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;

  &lt;xs:complexType name="getServiceConfiguration"&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element minOccurs="0" name="arg0" type="tns:WSServiceGetConfiguration"/&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;

  &lt;xs:complexType name="WSServiceGetConfiguration"&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element minOccurs="0" name="jndiName" type="xs:string"/&gt;
      &lt;xs:element minOccurs="0" name="optionalParameter" type="xs:string"/&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;

  &lt;xs:complexType name="getServiceConfigurationResponse"&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element minOccurs="0" name="return" type="tns:WSString"/&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;

  &lt;xs:complexType name="existsDBDataCluster"&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element minOccurs="0" name="arg0" type="tns:WSExistsDBDataCluster"/&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;

  &lt;xs:complexType name="WSExistsDBDataCluster"&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element minOccurs="0" name="name" type="xs:string"/&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;

  &lt;xs:complexType name="existsDBDataClusterResponse"&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element minOccurs="0" name="return" type="tns:WSBoolean"/&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;

  &lt;xs:complexType name="getTransformerPluginV2SList"&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element minOccurs="0" name="arg0" type="tns:WSGetTransformerPluginV2SList"/&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;

  &lt;xs:complexType name="WSGetTransformerPluginV2SList"&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element minOccurs="0" name="language" type="xs:string"/&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;

  &lt;xs:complexType name="getTransformerPluginV2SListResponse"&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element minOccurs="0" name="return" type="tns:WSTransformerPluginV2SList"/&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;

  &lt;xs:complexType name="WSTransformerPluginV2SList"&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element maxOccurs="unbounded" minOccurs="0" name="item" nillable="true" type="tns:WSTransformerPluginV2SListItem"/&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;

  &lt;xs:complexType name="WSTransformerPluginV2SListItem"&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element minOccurs="0" name="description" type="xs:string"/&gt;
      &lt;xs:element minOccurs="0" name="jndiName" type="xs:string"/&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;

  &lt;xs:complexType name="getRolePKs"&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element minOccurs="0" name="arg0" type="tns:WSGetRolePKs"/&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;

  &lt;xs:complexType name="WSGetRolePKs"&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element minOccurs="0" name="regex" type="xs:string"/&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;

  &lt;xs:complexType name="getRolePKsResponse"&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element minOccurs="0" name="return" type="tns:WSRolePKArray"/&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;

  &lt;xs:complexType name="WSRolePKArray"&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element maxOccurs="unbounded" minOccurs="0" name="wsRolePK" nillable="true" type="tns:WSRolePK"/&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;

  &lt;xs:complexType name="existsRoutingRule"&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element minOccurs="0" name="arg0" type="tns:WSExistsRoutingRule"/&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;

  &lt;xs:complexType name="WSExistsRoutingRule"&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element minOccurs="0" name="wsRoutingRulePK" type="tns:WSRoutingRulePK"/&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;

  &lt;xs:complexType name="existsRoutingRuleResponse"&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element minOccurs="0" name="return" type="tns:WSBoolean"/&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;

  &lt;xs:complexType name="getMDMConfiguration"&gt;
    &lt;xs:sequence/&gt;
  &lt;/xs:complexType&gt;

  &lt;xs:complexType name="getMDMConfigurationResponse"&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element minOccurs="0" name="return" type="tns:WSMDMConfig"/&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;

  &lt;xs:complexType name="WSMDMConfig"&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element minOccurs="0" name="isupurl" type="xs:string"/&gt;
      &lt;xs:element minOccurs="0" name="password" type="xs:string"/&gt;
      &lt;xs:element minOccurs="0" name="serverName" type="xs:string"/&gt;
      &lt;xs:element minOccurs="0" name="serverPort" type="xs:string"/&gt;
      &lt;xs:element minOccurs="0" name="userName" type="xs:string"/&gt;
      &lt;xs:element minOccurs="0" name="xdbDriver" type="xs:string"/&gt;
      &lt;xs:element minOccurs="0" name="xdbID" type="xs:string"/&gt;
      &lt;xs:element minOccurs="0" name="xdbUrl" type="xs:string"/&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;

  &lt;xs:complexType name="deleteDataCluster"&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element minOccurs="0" name="arg0" type="tns:WSDeleteDataCluster"/&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;

  &lt;xs:complexType name="WSDeleteDataCluster"&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element minOccurs="0" name="wsDataClusterPK" type="tns:WSDataClusterPK"/&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;

  &lt;xs:complexType name="deleteDataClusterResponse"&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element minOccurs="0" name="return" type="tns:WSDataClusterPK"/&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;

  &lt;xs:complexType name="executeRoutingOrderV2Asynchronously"&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element minOccurs="0" name="arg0" type="tns:WSExecuteRoutingOrderV2Asynchronously"/&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;

  &lt;xs:complexType name="WSExecuteRoutingOrderV2Asynchronously"&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element minOccurs="0" name="routingOrderV2PK" type="tns:WSRoutingOrderV2PK"/&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;

  &lt;xs:complexType name="executeRoutingOrderV2AsynchronouslyResponse"&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element minOccurs="0" name="return" type="tns:WSRoutingOrderV2PK"/&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;

  &lt;xs:complexType name="existsDataModel"&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element minOccurs="0" name="arg0" type="tns:WSExistsDataModel"/&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;

  &lt;xs:complexType name="WSExistsDataModel"&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element minOccurs="0" name="wsDataModelPK" type="tns:WSDataModelPK"/&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;

  &lt;xs:complexType name="existsDataModelResponse"&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element minOccurs="0" name="return" type="tns:WSBoolean"/&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;

  &lt;xs:complexType name="putMenu"&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element minOccurs="0" name="arg0" type="tns:WSPutMenu"/&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;

  &lt;xs:complexType name="WSPutMenu"&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element minOccurs="0" name="wsMenu" type="tns:WSMenu"/&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;

  &lt;xs:complexType name="putMenuResponse"&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element minOccurs="0" name="return" type="tns:WSMenuPK"/&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;

  &lt;xs:complexType name="getItem"&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element minOccurs="0" name="arg0" type="tns:WSGetItem"/&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;

  &lt;xs:complexType name="WSGetItem"&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element minOccurs="0" name="wsItemPK" type="tns:WSItemPK"/&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;

  &lt;xs:complexType name="getItemResponse"&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element minOccurs="0" name="return" type="tns:WSItem"/&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;

  &lt;xs:complexType name="extractThroughTransformerV2"&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element minOccurs="0" name="arg0" type="tns:WSExtractThroughTransformerV2"/&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;

  &lt;xs:complexType name="WSExtractThroughTransformerV2"&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element minOccurs="0" name="wsItemPK" type="tns:WSItemPK"/&gt;
      &lt;xs:element minOccurs="0" name="wsTransformerV2PK" type="tns:WSTransformerV2PK"/&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;

  &lt;xs:complexType name="extractThroughTransformerV2Response"&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element minOccurs="0" name="return" type="tns:WSTransformerContext"/&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;

  &lt;xs:complexType name="checkSchema"&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element minOccurs="0" name="arg0" type="tns:WSCheckSchema"/&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;

  &lt;xs:complexType name="WSCheckSchema"&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element minOccurs="0" name="schema" type="xs:string"/&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;

  &lt;xs:complexType name="checkSchemaResponse"&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element minOccurs="0" name="return" type="tns:WSString"/&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;

  &lt;xs:complexType name="xPathsSearch"&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element minOccurs="0" name="arg0" type="tns:WSXPathsSearch"/&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;

  &lt;xs:complexType name="WSXPathsSearch"&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element minOccurs="0" name="direction" type="xs:string"/&gt;
      &lt;xs:element name="maxItems" type="xs:int"/&gt;
      &lt;xs:element minOccurs="0" name="orderBy" type="xs:string"/&gt;
      &lt;xs:element minOccurs="0" name="pivotPath" type="xs:string"/&gt;
      &lt;xs:element minOccurs="0" name="returnCount" type="xs:boolean"/&gt;
      &lt;xs:element name="skip" type="xs:int"/&gt;
      &lt;xs:element name="spellTreshold" type="xs:int"/&gt;
      &lt;xs:element minOccurs="0" name="viewablePaths" type="tns:WSStringArray"/&gt;
      &lt;xs:element minOccurs="0" name="whereItem" type="tns:WSWhereItem"/&gt;
      &lt;xs:element minOccurs="0" name="wsDataClusterPK" type="tns:WSDataClusterPK"/&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;

  &lt;xs:complexType name="xPathsSearchResponse"&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element minOccurs="0" name="return" type="tns:WSStringArray"/&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;

  &lt;xs:complexType name="putBusinessConceptSchema"&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element minOccurs="0" name="arg0" type="tns:WSPutBusinessConceptSchema"/&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;

  &lt;xs:complexType name="WSPutBusinessConceptSchema"&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element minOccurs="0" name="businessConceptSchema" type="xs:string"/&gt;
      &lt;xs:element minOccurs="0" name="wsDataModelPK" type="tns:WSDataModelPK"/&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;

  &lt;xs:complexType name="putBusinessConceptSchemaResponse"&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element minOccurs="0" name="return" type="tns:WSString"/&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;

  &lt;xs:complexType name="partialPutItem"&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element minOccurs="0" name="arg0" type="tns:WSPartialPutItem"/&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;

  &lt;xs:complexType name="WSPartialPutItem"&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element minOccurs="0" name="datacluster" type="xs:string"/&gt;
      &lt;xs:element minOccurs="0" name="datamodel" type="xs:string"/&gt;
      &lt;xs:element minOccurs="0" name="delete" type="xs:boolean"/&gt;
      &lt;xs:element minOccurs="0" name="keyXPath" type="xs:string"/&gt;
      &lt;xs:element minOccurs="0" name="overwrite" type="xs:boolean"/&gt;
      &lt;xs:element minOccurs="0" name="pivot" type="xs:string"/&gt;
      &lt;xs:element name="report" type="xs:boolean"/&gt;
      &lt;xs:element minOccurs="0" name="source" type="xs:string"/&gt;
      &lt;xs:element minOccurs="0" name="startingPosition" type="xs:int"/&gt;
      &lt;xs:element minOccurs="0" name="xml" type="xs:string"/&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;

  &lt;xs:complexType name="partialPutItemResponse"&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element minOccurs="0" name="return" type="tns:WSItemPK"/&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;

  &lt;xs:complexType name="existsItem"&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element minOccurs="0" name="arg0" type="tns:WSExistsItem"/&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;

  &lt;xs:complexType name="WSExistsItem"&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element minOccurs="0" name="wsItemPK" type="tns:WSItemPK"/&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;

  &lt;xs:complexType name="existsItemResponse"&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element minOccurs="0" name="return" type="tns:WSBoolean"/&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;

  &lt;xs:complexType name="putDataCluster"&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element minOccurs="0" name="arg0" type="tns:WSPutDataCluster"/&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;

  &lt;xs:complexType name="WSPutDataCluster"&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element minOccurs="0" name="wsDataCluster" type="tns:WSDataCluster"/&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;

  &lt;xs:complexType name="putDataClusterResponse"&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element minOccurs="0" name="return" type="tns:WSDataClusterPK"/&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;

  &lt;xs:complexType name="routingEngineV2Action"&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element minOccurs="0" name="arg0" type="tns:WSRoutingEngineV2Action"/&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;

  &lt;xs:complexType name="WSRoutingEngineV2Action"&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element minOccurs="0" name="wsAction" type="tns:WSRoutingEngineV2ActionCode"/&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;

  &lt;xs:complexType name="routingEngineV2ActionResponse"&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element minOccurs="0" name="return" type="tns:WSRoutingEngineV2Status"/&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;

  &lt;xs:complexType name="extractUsingTransformer"&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element minOccurs="0" name="arg0" type="tns:WSExtractUsingTransformer"/&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;

  &lt;xs:complexType name="WSExtractUsingTransformer"&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element minOccurs="0" name="wsItemPK" type="tns:WSItemPK"/&gt;
      &lt;xs:element minOccurs="0" name="wsTransformerPK" type="tns:WSTransformerPK"/&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;

  &lt;xs:complexType name="extractUsingTransformerResponse"&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element minOccurs="0" name="return" type="tns:WSPipeline"/&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;

  &lt;xs:complexType name="getServicesList"&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element minOccurs="0" name="arg0" type="tns:WSGetServicesList"/&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;

  &lt;xs:complexType name="WSGetServicesList"&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element minOccurs="0" name="language" type="xs:string"/&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;

  &lt;xs:complexType name="getServicesListResponse"&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element minOccurs="0" name="return" type="tns:WSServicesList"/&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;

  &lt;xs:complexType name="WSServicesList"&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element maxOccurs="unbounded" minOccurs="0" name="item" nillable="true" type="tns:WSServicesListItem"/&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;

  &lt;xs:complexType name="WSServicesListItem"&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element minOccurs="0" name="jndiName" type="xs:string"/&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;

  &lt;xs:complexType name="getView"&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element minOccurs="0" name="arg0" type="tns:WSGetView"/&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;

  &lt;xs:complexType name="WSGetView"&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element minOccurs="0" name="wsViewPK" type="tns:WSViewPK"/&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;

  &lt;xs:complexType name="getViewResponse"&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element minOccurs="0" name="return" type="tns:WSView"/&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;

  &lt;xs:complexType name="putRoutingRule"&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element minOccurs="0" name="arg0" type="tns:WSPutRoutingRule"/&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;

  &lt;xs:complexType name="WSPutRoutingRule"&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element minOccurs="0" name="wsRoutingRule" type="tns:WSRoutingRule"/&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;

  &lt;xs:complexType name="putRoutingRuleResponse"&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element minOccurs="0" name="return" type="tns:WSRoutingRulePK"/&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;

  &lt;xs:complexType name="getItems"&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element minOccurs="0" name="arg0" type="tns:WSGetItems"/&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;

  &lt;xs:complexType name="WSGetItems"&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element minOccurs="0" name="conceptName" type="xs:string"/&gt;
      &lt;xs:element name="maxItems" type="xs:int"/&gt;
      &lt;xs:element name="skip" type="xs:int"/&gt;
      &lt;xs:element name="spellTreshold" type="xs:int"/&gt;
      &lt;xs:element minOccurs="0" name="totalCountOnFirstResult" type="xs:boolean"/&gt;
      &lt;xs:element minOccurs="0" name="whereItem" type="tns:WSWhereItem"/&gt;
      &lt;xs:element minOccurs="0" name="wsDataClusterPK" type="tns:WSDataClusterPK"/&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;

  &lt;xs:complexType name="getItemsResponse"&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element minOccurs="0" name="return" type="tns:WSStringArray"/&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;

  &lt;xs:complexType name="isPagingAccurate"&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element minOccurs="0" name="arg0" type="tns:WSInt"/&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;

  &lt;xs:complexType name="isPagingAccurateResponse"&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element minOccurs="0" name="return" type="tns:WSBoolean"/&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;

  &lt;xs:complexType name="getAutoIncrement"&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element minOccurs="0" name="arg0" type="tns:WSAutoIncrement"/&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;

  &lt;xs:complexType name="WSAutoIncrement"&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element minOccurs="0" name="autoincrement" type="xs:string"/&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;

  &lt;xs:complexType name="getAutoIncrementResponse"&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element minOccurs="0" name="return" type="tns:WSAutoIncrement"/&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;

  &lt;xs:complexType name="executeTransformerV2AsJob"&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element minOccurs="0" name="arg0" type="tns:WSExecuteTransformerV2AsJob"/&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;

  &lt;xs:complexType name="WSExecuteTransformerV2AsJob"&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element minOccurs="0" name="wsTransformerContext" type="tns:WSTransformerContext"/&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;

  &lt;xs:complexType name="executeTransformerV2AsJobResponse"&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element minOccurs="0" name="return" type="tns:WSBackgroundJobPK"/&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;

  &lt;xs:complexType name="putBackgroundJob"&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element minOccurs="0" name="arg0" type="tns:WSPutBackgroundJob"/&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;

  &lt;xs:complexType name="WSPutBackgroundJob"&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element minOccurs="0" name="wsBackgroundJob" type="tns:WSBackgroundJob"/&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;

  &lt;xs:complexType name="putBackgroundJobResponse"&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element minOccurs="0" name="return" type="tns:WSBackgroundJobPK"/&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;

  &lt;xs:complexType name="putTransformerV2"&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element minOccurs="0" name="arg0" type="tns:WSPutTransformerV2"/&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;

  &lt;xs:complexType name="WSPutTransformerV2"&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element minOccurs="0" name="wsTransformerV2" type="tns:WSTransformerV2"/&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;

  &lt;xs:complexType name="putTransformerV2Response"&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element minOccurs="0" name="return" type="tns:WSTransformerV2PK"/&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;

  &lt;xs:complexType name="extractUsingTransformerThruView"&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element minOccurs="0" name="arg0" type="tns:WSExtractUsingTransformerThruView"/&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;

  &lt;xs:complexType name="WSExtractUsingTransformerThruView"&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element minOccurs="0" name="direction" type="xs:string"/&gt;
      &lt;xs:element name="maxItems" type="xs:int"/&gt;
      &lt;xs:element minOccurs="0" name="orderBy" type="xs:string"/&gt;
      &lt;xs:element name="skip" type="xs:int"/&gt;
      &lt;xs:element name="spellTreshold" type="xs:int"/&gt;
      &lt;xs:element minOccurs="0" name="whereItem" type="tns:WSWhereItem"/&gt;
      &lt;xs:element minOccurs="0" name="wsDataClusterPK" type="tns:WSDataClusterPK"/&gt;
      &lt;xs:element minOccurs="0" name="wsTransformerPK" type="tns:WSTransformerPK"/&gt;
      &lt;xs:element minOccurs="0" name="wsViewPK" type="tns:WSViewPK"/&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;

  &lt;xs:complexType name="extractUsingTransformerThruViewResponse"&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element minOccurs="0" name="return" type="tns:WSPipeline"/&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;

  &lt;xs:complexType name="getBusinessConceptValue"&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element minOccurs="0" name="arg0" type="tns:WSGetBusinessConceptValue"/&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;

  &lt;xs:complexType name="WSGetBusinessConceptValue"&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element minOccurs="0" name="wsBusinessConceptPK" type="tns:WSBusinessConceptPK"/&gt;
      &lt;xs:element minOccurs="0" name="wsDataClusterPK" type="tns:WSDataClusterPK"/&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;

  &lt;xs:complexType name="WSBusinessConceptPK"&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element minOccurs="0" name="conceptName" type="xs:string"/&gt;
      &lt;xs:element maxOccurs="unbounded" minOccurs="0" name="ids" nillable="true" type="xs:string"/&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;

  &lt;xs:complexType name="getBusinessConceptValueResponse"&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element minOccurs="0" name="return" type="tns:WSString"/&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;

  &lt;xs:simpleType name="BackgroundJobStatusType"&gt;
    &lt;xs:restriction base="xs:string"&gt;
      &lt;xs:enumeration value="SCHEDULED"/&gt;
      &lt;xs:enumeration value="RUNNING"/&gt;
      &lt;xs:enumeration value="COMPLETED"/&gt;
      &lt;xs:enumeration value="SUSPENDED"/&gt;
      &lt;xs:enumeration value="CANCEL_REQUESTED"/&gt;
      &lt;xs:enumeration value="STOPPED"/&gt;
    &lt;/xs:restriction&gt;
  &lt;/xs:simpleType&gt;

  &lt;xs:simpleType name="WSWhereOperator"&gt;
    &lt;xs:restriction base="xs:string"&gt;
      &lt;xs:enumeration value="JOIN"/&gt;
      &lt;xs:enumeration value="CONTAINS_TEXT_OF"/&gt;
      &lt;xs:enumeration value="CONTAINS"/&gt;
      &lt;xs:enumeration value="STARTSWITH"/&gt;
      &lt;xs:enumeration value="STRICTCONTAINS"/&gt;
      &lt;xs:enumeration value="EQUALS"/&gt;
      &lt;xs:enumeration value="NOT_EQUALS"/&gt;
      &lt;xs:enumeration value="GREATER_THAN"/&gt;
      &lt;xs:enumeration value="GREATER_THAN_OR_EQUAL"/&gt;
      &lt;xs:enumeration value="LOWER_THAN"/&gt;
      &lt;xs:enumeration value="LOWER_THAN_OR_EQUAL"/&gt;
      &lt;xs:enumeration value="NO_OPERATOR"/&gt;
      &lt;xs:enumeration value="FULLTEXTSEARCH"/&gt;
      &lt;xs:enumeration value="EMPTY_NULL"/&gt;
    &lt;/xs:restriction&gt;
  &lt;/xs:simpleType&gt;

  &lt;xs:simpleType name="WSStringPredicate"&gt;
    &lt;xs:restriction base="xs:string"&gt;
      &lt;xs:enumeration value="NONE"/&gt;
      &lt;xs:enumeration value="OR"/&gt;
      &lt;xs:enumeration value="AND"/&gt;
      &lt;xs:enumeration value="STRICTAND"/&gt;
      &lt;xs:enumeration value="EXACTLY"/&gt;
      &lt;xs:enumeration value="NOT"/&gt;
    &lt;/xs:restriction&gt;
  &lt;/xs:simpleType&gt;

  &lt;xs:simpleType name="WSRoutingOrderV2Status"&gt;
    &lt;xs:restriction base="xs:string"&gt;
      &lt;xs:enumeration value="ACTIVE"/&gt;
      &lt;xs:enumeration value="FAILED"/&gt;
      &lt;xs:enumeration value="COMPLETED"/&gt;
    &lt;/xs:restriction&gt;
  &lt;/xs:simpleType&gt;

  &lt;xs:simpleType name="fkIntegrityCheckResult"&gt;
    &lt;xs:restriction base="xs:string"&gt;
      &lt;xs:enumeration value="FORBIDDEN"/&gt;
      &lt;xs:enumeration value="FORBIDDEN_OVERRIDE_ALLOWED"/&gt;
      &lt;xs:enumeration value="ALLOWED"/&gt;
    &lt;/xs:restriction&gt;
  &lt;/xs:simpleType&gt;

  &lt;xs:simpleType name="WSComponent"&gt;
    &lt;xs:restriction base="xs:string"&gt;
      &lt;xs:enumeration value="DataManager"/&gt;
      &lt;xs:enumeration value="Service"/&gt;
      &lt;xs:enumeration value="Connector"/&gt;
    &lt;/xs:restriction&gt;
  &lt;/xs:simpleType&gt;

  &lt;xs:simpleType name="WSRoutingRuleOperator"&gt;
    &lt;xs:restriction base="xs:string"&gt;
      &lt;xs:enumeration value="CONTAINS"/&gt;
      &lt;xs:enumeration value="MATCHES"/&gt;
      &lt;xs:enumeration value="STARTSWITH"/&gt;
      &lt;xs:enumeration value="EQUALS"/&gt;
      &lt;xs:enumeration value="NOT_EQUALS"/&gt;
      &lt;xs:enumeration value="GREATER_THAN"/&gt;
      &lt;xs:enumeration value="GREATER_THAN_OR_EQUAL"/&gt;
      &lt;xs:enumeration value="LOWER_THAN"/&gt;
      &lt;xs:enumeration value="LOWER_THAN_OR_EQUAL"/&gt;
      &lt;xs:enumeration value="IS_NULL"/&gt;
      &lt;xs:enumeration value="IS_NOT_NULL"/&gt;
    &lt;/xs:restriction&gt;
  &lt;/xs:simpleType&gt;

  &lt;xs:simpleType name="WSLanguage"&gt;
    &lt;xs:restriction base="xs:string"&gt;
      &lt;xs:enumeration value="FR"/&gt;
      &lt;xs:enumeration value="EN"/&gt;
    &lt;/xs:restriction&gt;
  &lt;/xs:simpleType&gt;

  &lt;xs:simpleType name="WSServiceActionCode"&gt;
    &lt;xs:restriction base="xs:string"&gt;
      &lt;xs:enumeration value="START"/&gt;
      &lt;xs:enumeration value="STOP"/&gt;
      &lt;xs:enumeration value="STATUS"/&gt;
      &lt;xs:enumeration value="EXECUTE"/&gt;
    &lt;/xs:restriction&gt;
  &lt;/xs:simpleType&gt;

  &lt;xs:simpleType name="WSRoutingEngineV2ActionCode"&gt;
    &lt;xs:restriction base="xs:string"&gt;
      &lt;xs:enumeration value="START"/&gt;
      &lt;xs:enumeration value="STOP"/&gt;
      &lt;xs:enumeration value="SUSPEND"/&gt;
      &lt;xs:enumeration value="RESUME"/&gt;
      &lt;xs:enumeration value="STATUS"/&gt;
    &lt;/xs:restriction&gt;
  &lt;/xs:simpleType&gt;

  &lt;xs:simpleType name="WSRoutingEngineV2Status"&gt;
    &lt;xs:restriction base="xs:string"&gt;
      &lt;xs:enumeration value="DEAD"/&gt;
      &lt;xs:enumeration value="STOPPED"/&gt;
      &lt;xs:enumeration value="SUSPENDED"/&gt;
      &lt;xs:enumeration value="RUNNING"/&gt;
    &lt;/xs:restriction&gt;
  &lt;/xs:simpleType&gt;

&lt;/xs:schema&gt;</string></schemas><encoding reference="../../../../../../../../../../input/payload/fields/org.mule.common.metadata.DefaultMetaDataField/model/fields/org.mule.common.metadata.DefaultMetaDataField[3]/model/fields/org.mule.common.metadata.DefaultMetaDataField[2]/model/schemas/encoding"></encoding><baseUri>http://127.0.0.1:8080/talendmdm/services/soap?wsdl</baseUri></schemas><rootElement><namespaceURI>http://www.talend.com/mdm</namespaceURI><localPart>putItemWithReportResponse</localPart><prefix></prefix></rootElement></model><accessType>READ_WRITE</accessType><metaDataFieldPropertyManager><properties><org.mule.common.metadata.property.QNameMetaDataProperty><name><namespaceURI></namespaceURI><localPart>wsDataClusterPK</localPart><prefix></prefix></name></org.mule.common.metadata.property.QNameMetaDataProperty></properties></metaDataFieldPropertyManager></org.mule.common.metadata.DefaultMetaDataField></fields><schemas class="org.mule.common.metadata.StringBasedSchemaProvider" reference="../fields/org.mule.common.metadata.DefaultMetaDataField[3]/model/schemas"></schemas><rootElement reference="../fields/org.mule.common.metadata.DefaultMetaDataField[3]/model/rootElement"></rootElement></model><accessType>READ_WRITE</accessType><metaDataFieldPropertyManager><properties><org.mule.common.metadata.property.QNameMetaDataProperty><name><namespaceURI></namespaceURI><localPart>return</localPart><prefix></prefix></name></org.mule.common.metadata.property.QNameMetaDataProperty></properties></metaDataFieldPropertyManager></org.mule.common.metadata.DefaultMetaDataField></fields><schemas class="org.mule.common.metadata.StringBasedSchemaProvider"><schemas reference="../../fields/org.mule.common.metadata.DefaultMetaDataField/model/fields/org.mule.common.metadata.DefaultMetaDataField[3]/model/schemas/schemas"></schemas><encoding reference="../../../../input/payload/fields/org.mule.common.metadata.DefaultMetaDataField/model/fields/org.mule.common.metadata.DefaultMetaDataField[3]/model/fields/org.mule.common.metadata.DefaultMetaDataField[2]/model/schemas/encoding"></encoding><baseUri>http://127.0.0.1:8080/talendmdm/services/soap?wsdl</baseUri></schemas><rootElement reference="../fields/org.mule.common.metadata.DefaultMetaDataField/model/fields/org.mule.common.metadata.DefaultMetaDataField[3]/model/rootElement"></rootElement></payload><properties><entry><org.mule.common.metadata.MetaDataPropertyScope>RECORD</org.mule.common.metadata.MetaDataPropertyScope><org.mule.common.metadata.MetaDataProperties><fields></fields></org.mule.common.metadata.MetaDataProperties></entry><entry><org.mule.common.metadata.MetaDataPropertyScope>INBOUND</org.mule.common.metadata.MetaDataPropertyScope><org.mule.common.metadata.MetaDataProperties><fields></fields></org.mule.common.metadata.MetaDataProperties></entry><entry><org.mule.common.metadata.MetaDataPropertyScope>OUTBOUND</org.mule.common.metadata.MetaDataPropertyScope><org.mule.common.metadata.MetaDataProperties><fields></fields></org.mule.common.metadata.MetaDataProperties></entry><entry><org.mule.common.metadata.MetaDataPropertyScope>SESSION</org.mule.common.metadata.MetaDataPropertyScope><org.mule.common.metadata.MetaDataProperties><fields></fields></org.mule.common.metadata.MetaDataProperties></entry><entry><org.mule.common.metadata.MetaDataPropertyScope>FLOW</org.mule.common.metadata.MetaDataPropertyScope><org.mule.common.metadata.MetaDataProperties><fields></fields></org.mule.common.metadata.MetaDataProperties></entry></properties></output></org.mule.tooling.metadata.cache.DefaultMetadataCacheEntry></entry></map></entry></map></entry></projectMetadataCache></org.mule.tooling.metadata.cache.MetadataCache>